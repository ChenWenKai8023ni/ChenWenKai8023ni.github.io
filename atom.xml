<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风吹过得夏天</title>
  
  <subtitle>既然青春留不住,还是做个大叔好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chenwenkai8023ni.github.io/"/>
  <updated>2020-08-01T08:50:15.749Z</updated>
  <id>https://chenwenkai8023ni.github.io/</id>
  
  <author>
    <name>风吹过得夏天</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS apply.call.bind</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/c0aac05a.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/c0aac05a.html</id>
    <published>2020-08-01T08:32:07.000Z</published>
    <updated>2020-08-01T08:50:15.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="apply、call、bind"><a href="#apply、call、bind" class="headerlink" title="apply、call、bind"></a>apply、call、bind</h2><p>前端面试题</p><a id="more"></a><ul><li>apply 、 call 、bind 三者都是用来改变函数的 this 对象的指向的；</li><li>apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；</li><li>apply 、 call 、bind 三者都可以利用后续参数传参</li><li>bind 是返回对应函数，便于稍后调用；apply、call 则是立即调用 。</li><li>call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。</li><li>某个函数的参数是明确知道数量时用 call ; 而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数</li><li>func.call(this, arg1, arg2);</li><li>func.apply(this, [arg1, arg2])</li></ul><h3 id="apply、call"><a href="#apply、call" class="headerlink" title="apply、call"></a>apply、call</h3><p>在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。<br>JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。<br>先来一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fruits</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">fruits.prototype = &#123;</span><br><span class="line">  color: <span class="string">"red"</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"My color is "</span> + <span class="keyword">this</span>.color);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> fruits();</span><br><span class="line">apple.say(); <span class="comment">//My color is red</span></span><br></pre></td></tr></table></figure><p>但是如果我们有一个对象 banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">banana = &#123;</span><br><span class="line">  color: <span class="string">"yellow"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">apple.say.call(banana); <span class="comment">//My color is yellow</span></span><br><span class="line">apple.say.apply(banana); <span class="comment">//My color is yellow</span></span><br></pre></td></tr></table></figure><p>所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中 banana 没有 say 方法），但是其他的有（本栗子中 apple 有 say 方法），我们可以借助 call 或 apply 用其它对象的方法来操作。</p><h3 id="apply、call-的区别"><a href="#apply、call-的区别" class="headerlink" title="apply、call 的区别"></a>apply、call 的区别</h3><p>对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">//就可以通过如下方式来调用：</span></span><br><span class="line">func.call(<span class="keyword">this</span>, arg1, arg2);</span><br><span class="line">func.apply(<span class="keyword">this</span>, [arg1, arg2]);</span><br></pre></td></tr></table></figure><p>其中 this 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。<br>JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call 。<br>而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。<br>为了巩固加深记忆，下面列举一些常用用法：</p><h4 id="数组之间追加"><a href="#数组之间追加" class="headerlink" title="数组之间追加"></a>数组之间追加</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> array1 = [<span class="number">12</span> , <span class="string">"foo"</span> , &#123;name <span class="string">"Joe"</span>&#125; , <span class="number">-2458</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">"Doe"</span> , <span class="number">555</span> , <span class="number">100</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(array1, array2);</span><br><span class="line"><span class="comment">/* array1 值为 [12 , "foo" , &#123;name "Joe"&#125; , -2458 , "Doe" , 555 , 100] */</span></span><br></pre></td></tr></table></figure><h4 id="获取数组中的最大值和最小值"><a href="#获取数组中的最大值和最小值" class="headerlink" title="获取数组中的最大值和最小值"></a>获取数组中的最大值和最小值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">5</span>, <span class="number">458</span>, <span class="number">120</span>, <span class="number">-215</span>];</span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, numbers), <span class="comment">//458</span></span><br><span class="line">  maxInNumbers = <span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>, <span class="number">5</span>, <span class="number">458</span>, <span class="number">120</span>, <span class="number">-215</span>); <span class="comment">//458</span></span><br></pre></td></tr></table></figure><p>number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。 验证是否是数组（前提是 toString()方法没有被重写过）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">functionisArray(obj)&#123;</span><br><span class="line">    returnObject.prototype.toString.call(obj) === <span class="string">'[object Array]'</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深入理解运用-apply、call"><a href="#深入理解运用-apply、call" class="headerlink" title="深入理解运用 apply、call"></a>深入理解运用 apply、call</h3><p>下面就借用一道面试题，来更深入的去理解下 apply 和 call 。 定义一个 log 方法，让它可以代理 console.log 方法，常见的解决方法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg</span>)&amp;<span class="title">emsp</span>;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;log(<span class="number">1</span>); <span class="comment">//1</span></span><br><span class="line">log(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>上面方法可以解决最基本的需求，但是当传入参数的个数是不确定的时候，上面的方法就失效了，这个时候就可以考虑使用 apply 或者 call，注意这里传入多少个参数是不确定的，所以使用 apply 是最好的，方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">1</span>); <span class="comment">//1</span></span><br><span class="line">log(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//1 2</span></span><br></pre></td></tr></table></figure><p>接下来的要求是给每一个 log 消息添加一个”(app)”的前辍，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="string">"hello world"</span>); <span class="comment">//(app)hello world</span></span><br></pre></td></tr></table></figure><p>该怎么做比较优雅呢?这个时候需要想到 arguments 参数是个伪数组，通过 Array.prototype.slice.call 转化为标准数组，再使用数组方法 unshift，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  args.unshift(<span class="string">"(app)"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。<br>MDN 的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。<br>直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar: <span class="number">1</span>,</span><br><span class="line">  eventBind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    $(<span class="string">".someClass"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/* Act on the event */</span></span><br><span class="line">      <span class="built_in">console</span>.log(_this.bar); <span class="comment">//1</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar: <span class="number">1</span>,</span><br><span class="line">  eventBind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">".someClass"</span>).on(</span><br><span class="line">      <span class="string">"click"</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* Act on the event */</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar); <span class="comment">//1</span></span><br><span class="line">      &#125;.bind(<span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码里，bind() 创建了一个函数，当这个 click 事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用 bind()时传入的参数）。因此，这里我们传入想要的上下文 this(其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向 foo 对象。再来一个简单的栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;;</span><br><span class="line">bar(); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo);</span><br><span class="line">func(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。<br>有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> sed = &#123;</span><br><span class="line">  x: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo).bind(sed);</span><br><span class="line">func(); <span class="comment">//?</span></span><br><span class="line"><span class="keyword">var</span> fiv = &#123;</span><br><span class="line">  x: <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo).bind(sed).bind(fiv);</span><br><span class="line">func(); <span class="comment">//?</span></span><br></pre></td></tr></table></figure><p>答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。</p><p>原因是，在 Javascript 中，多次 bind() 是无效的。<br>更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。</p><h3 id="apply、call、bind-比较"><a href="#apply、call、bind-比较" class="headerlink" title="apply、call、bind 比较"></a>apply、call、bind 比较</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">x</span>: <span class="number">81</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.bind(obj)()); <span class="comment">//81</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.call(obj)); <span class="comment">//81</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.apply(obj)); <span class="comment">//81</span></span><br></pre></td></tr></table></figure><p>三个输出的都是 81，但是注意看使用 bind() 方法的，他后面多了对括号。</p><p>也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>apply 、 call 、bind 三者都是用来改变函数的 this 对象的指向的；<br>apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；<br>apply 、 call 、bind 三者都可以利用后续参数传参；<br>bind 是返回对应函数，便于稍后调用；apply、call 则是立即调用 。</p><p>作者：鬼小妞<br>链接：<a href="https://juejin.im/post/6844903920792240142" target="_blank" rel="noopener">https://juejin.im/post/6844903920792240142</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;apply、call、bind&quot;&gt;&lt;a href=&quot;#apply、call、bind&quot; class=&quot;headerlink&quot; title=&quot;apply、call、bind&quot;&gt;&lt;/a&gt;apply、call、bind&lt;/h2&gt;&lt;p&gt;前端面试题&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="js" scheme="https://chenwenkai8023ni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Vue初级知识汇总</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/8fd4d428.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/8fd4d428.html</id>
    <published>2020-07-25T00:52:23.000Z</published>
    <updated>2020-07-25T07:51:30.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-初级知识汇总"><a href="#Vue-初级知识汇总" class="headerlink" title="Vue 初级知识汇总"></a>Vue 初级知识汇总</h2><a id="more"></a><h3 id="Vue2-0-兼容-IE-哪个版本以上吗"><a href="#Vue2-0-兼容-IE-哪个版本以上吗" class="headerlink" title="Vue2.0 兼容 IE 哪个版本以上吗"></a>Vue2.0 兼容 IE 哪个版本以上吗</h3><details>    不支持ie8及以下，部分兼容ie9 ，完全兼容10以上， 因为vue的响应式原理是基于es5的Object.defineProperty(),而这个方法不支持ie8及以下。</details><h3 id="vue-的生命周期是什么"><a href="#vue-的生命周期是什么" class="headerlink" title="vue 的生命周期是什么"></a>vue 的生命周期是什么</h3><details><ul><li><code>beforeCreate</code>:实例创建前被调用</li><li><code>created</code> :实例创建后被调用,完成数据观测,属性和方法的运算,watch/event 实际回调,模板渲染成 html(vm.$el 未定义),数据初始化最好在这个阶段完成</li><li><code>beforeMount</code> : 在$el挂载前被调用，相关的 render 函数首次被调用，期间将模块渲染成html,此时vm.$el 还是未定义；</li><li><code>mounted</code> : 在$el挂载后被调用，此时vm.$el 可以调用，不能保证所有的子组件都挂载，要等视图全部更新完毕用 vm.$nextTick()</li><li><code>beforeUpdate</code>:数据更新时调用;</li><li><code>updated</code> :数据更新后调用;</li><li><code>activated</code> :<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>包裹的组件激活时调用</li><li><code>deactivated</code> :<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>包裹的组件离开时调用</li><li><code>beforeDestroy</code> :实例销毁之前调用,此时实例仍然完全可用；</li><li><code>destroyed</code> :实例销毁之后调用,此时实例的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul></details><h3 id="computed-中的属性名和-data-中的属性名可以相同么"><a href="#computed-中的属性名和-data-中的属性名可以相同么" class="headerlink" title="computed 中的属性名和 data 中的属性名可以相同么"></a>computed 中的属性名和 data 中的属性名可以相同么</h3><details>不能同名，因为不管是computed属性名还是data数据名还是props数据名都会被挂载在vm实例上，因此这三个都不能同名</details><h3 id="怎么缓存当前打开的路由组件，缓存后想更新当前组件怎么办呢"><a href="#怎么缓存当前打开的路由组件，缓存后想更新当前组件怎么办呢" class="headerlink" title="怎么缓存当前打开的路由组件，缓存后想更新当前组件怎么办呢"></a>怎么缓存当前打开的路由组件，缓存后想更新当前组件怎么办呢</h3><details>用`<keep-alive></keep-alive>`内置组件包裹路由组件,在钩子函数activated中更新。</details><h3 id="跟-keep-alive-有关的生命周期是哪些"><a href="#跟-keep-alive-有关的生命周期是哪些" class="headerlink" title="跟 keep-alive 有关的生命周期是哪些"></a>跟 keep-alive 有关的生命周期是哪些</h3><details>- activated钩子：keep-alive 组件激活时调用。- deactivated钩子：keep-alive 组件停用时调用。- 以上钩子服务器端渲染期间不被调用。</details><h3 id="watch-的属性使用箭头函数定义可以吗"><a href="#watch-的属性使用箭头函数定义可以吗" class="headerlink" title="watch 的属性使用箭头函数定义可以吗"></a>watch 的属性使用箭头函数定义可以吗</h3><details>不可以。this会是undefind,因为箭头函数中的this指向的是定义时的this，而不是执行时的this，所以不会指向Vue实例的上下文。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">    show:<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)<span class="comment">//undefind this会指向show</span></span><br><span class="line">    &#125;,</span><br><span class="line">    id(val)&#123;</span><br><span class="line">        conosle.log(<span class="keyword">this</span>)<span class="comment">//Vue实例对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="怎么在-watch-监听开始之后立即被调用"><a href="#怎么在-watch-监听开始之后立即被调用" class="headerlink" title="怎么在 watch 监听开始之后立即被调用"></a>怎么在 watch 监听开始之后立即被调用</h3><details>在选项参数中指定immediate: true将立即以表达式的当前值触发回调。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">   a:&#123;</span><br><span class="line">       handler:<span class="function"><span class="keyword">function</span>(<span class="params">val,oldval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;,</span><br><span class="line">      immediate: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="watch-怎么深度监听对象变化"><a href="#watch-怎么深度监听对象变化" class="headerlink" title="watch 怎么深度监听对象变化"></a>watch 怎么深度监听对象变化</h3><details>在选项参数中指定 deep:true。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">   a:&#123;</span><br><span class="line">       handler:<span class="function"><span class="keyword">function</span>(<span class="params">val,oldval</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;,</span><br><span class="line">      deep:<span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="怎么强制刷新组件"><a href="#怎么强制刷新组件" class="headerlink" title="怎么强制刷新组件"></a>怎么强制刷新组件</h3><details><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;demo :key&#x3D;&quot;count&quot;&gt;&lt;&#x2F;demo&gt; &#x2F;&#x2F; 绑定key值</span><br><span class="line">    &lt;button @click&#x3D;&quot;handleRefresh&quot;&gt;刷新demo组件&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import demo from &quot;.&#x2F;test.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;refreshDemo&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0 </span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleRefresh() &#123;</span><br><span class="line">      this.count +&#x3D; 1 &#x2F;&#x2F; 更改key值，从而达到刷新组件的效果 当key改变时就是释放原始组件，重新加载新的组件</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></details><h3 id="父组件中的自定义事件怎么接收子组件的多个参数"><a href="#父组件中的自定义事件怎么接收子组件的多个参数" class="headerlink" title="父组件中的自定义事件怎么接收子组件的多个参数"></a>父组件中的自定义事件怎么接收子组件的多个参数</h3><details>this.$emit('eventName',data),data可以是个对象，包含子组件的多个参数，然后传给父组件。</details><h3 id="给组件绑定自定义事件无效怎么解决"><a href="#给组件绑定自定义事件无效怎么解决" class="headerlink" title="给组件绑定自定义事件无效怎么解决"></a>给组件绑定自定义事件无效怎么解决</h3><details>加上修饰词.native否则无法触发事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Main @click.native&#x3D;&quot;shuchu&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Main from &quot;.&#x2F;components&#x2F;main&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Main</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    shuchu() &#123;</span><br><span class="line">      console.log(&quot;1&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></details><h3 id="怎么访问子组件的实例或者子元素"><a href="#怎么访问子组件的实例或者子元素" class="headerlink" title="怎么访问子组件的实例或者子元素"></a>怎么访问子组件的实例或者子元素</h3><details><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;buttom @click&#x3D;&quot;shuchu&quot; &gt;&lt;&#x2F;buttom&gt;</span><br><span class="line">    &lt;Main ref &#x3D;&quot;main&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Main from &quot;.&#x2F;components&#x2F;main&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Main</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    shuchu() &#123;</span><br><span class="line">    &#x2F;&#x2F;通过使用this.$refs.main.方法名可以调用子组件内methods内的方法</span><br><span class="line">    this.$refs.main.方法名</span><br><span class="line">    &#x2F;&#x2F;获取子组件data数据</span><br><span class="line">    this.$refs.main.$data</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">ref</span>=<span class="string">"mydiv"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>第一个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>第二个li<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">console.log(this.$refs['mydiv']</span><br><span class="line">.getElementsByClassName('item')[0].innerHTML)//第一个</span><br></pre></td></tr></table></figure></details><h3 id="怎么在子组件中访问父组件的实例"><a href="#怎么在子组件中访问父组件的实例" class="headerlink" title="怎么在子组件中访问父组件的实例"></a>怎么在子组件中访问父组件的实例</h3><details><p>在子组件中使用<code>this.$parent</code>来访问</p></details><h3 id="怎么在组件中访问到根实例"><a href="#怎么在组件中访问到根实例" class="headerlink" title="怎么在组件中访问到根实例"></a>怎么在组件中访问到根实例</h3><details><p>在子组件中使用<code>this.$root</code>来访问</p></details><h3 id="组件会在什么时候下被销毁"><a href="#组件会在什么时候下被销毁" class="headerlink" title="组件会在什么时候下被销毁"></a>组件会在什么时候下被销毁</h3><details><ul><li>没有使用 keep-alive 时的路由切换；</li><li>v-if=’false’；</li><li>执行 vm.$destroy()；</details></li></ul><h3 id="Vue-组件之间的通信都有哪些"><a href="#Vue-组件之间的通信都有哪些" class="headerlink" title="Vue 组件之间的通信都有哪些"></a>Vue 组件之间的通信都有哪些</h3><details><ul><li>props</li><li>this.$emit(‘input’,data)</li><li>this.$root.$on(‘input’,function(data){})和 this.$root.$emit(‘emit’,data)</li><li>this.$refs.tree(tree 为 ref 绑定值)</li><li>Vuex</li></ul></details><h3 id="prop-验证的-type-类型有哪几种-可以设置默认值吗"><a href="#prop-验证的-type-类型有哪几种-可以设置默认值吗" class="headerlink" title="prop 验证的 type 类型有哪几种 ,可以设置默认值吗"></a>prop 验证的 type 类型有哪几种 ,可以设置默认值吗</h3><details><p>String、Number、Boolean、Array、Object、Date、Function、Symbol， 此外还可以是一个自定义的构造函数 Personnel，并且通过 instanceof 来验证 propwokrer 的值是否是通过这个自定义的构造函数创建的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Personnel</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    wokrer: Personnel,</span><br><span class="line">    propA: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    propB: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    propC: <span class="built_in">Boolean</span>,</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="keyword">default</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h3 id="在-Vue-事件中是如何使用-event-对象的"><a href="#在-Vue-事件中是如何使用-event-对象的" class="headerlink" title="在 Vue 事件中是如何使用 event 对象的"></a>在 Vue 事件中是如何使用 event 对象的</h3><details><ul><li><code>@click=&quot;handleOpen&quot;</code> 默认第一个参数传入 event 对象;</li><li><code>@click=&quot;handleOpen(0, $event)</code>,如果自己需要传入参数和 event 对象，则需要使用$event 来获取 event 对象并传入 handleOpen。</details></li></ul><h3 id="在-Vue-事件中传入-event，使用-event-target-和-event-currentTarget-有什么区别"><a href="#在-Vue-事件中传入-event，使用-event-target-和-event-currentTarget-有什么区别" class="headerlink" title="在 Vue 事件中传入$event，使用$event.target 和$event.currentTarget 有什么区别"></a>在 Vue 事件中传入$event，使用$event.target 和$event.currentTarget 有什么区别</h3><details><p><code>$event.currentTarget</code>始终指向事件所绑定的元素，而<code>$event.target</code>指向事件发生时的元素。</p></details><h3 id="表单修饰符和事件修饰符"><a href="#表单修饰符和事件修饰符" class="headerlink" title="表单修饰符和事件修饰符"></a>表单修饰符和事件修饰符</h3><details><ul><li><p>.stop：阻止事件传递</p></li><li><p>.prevent： 阻止默认事件；</p></li><li><p>.capture ：在捕获的过程监听，没有 capture 修饰符时都是默认冒泡过程 监听；</p></li><li><p>.self：当前绑定事件的元素才能触发；</p></li><li><p>.once：事件只会触发一次；</p></li><li><p>.passive：默认事件会立即触发，不要把.passive 和.prevent 一起使用，因为.prevent 将不起作用。</p></li><li><p>表单修饰符.number .lazy .trim</p></details></li></ul><h3 id="使用事件修饰符要注意"><a href="#使用事件修饰符要注意" class="headerlink" title="使用事件修饰符要注意"></a>使用事件修饰符要注意</h3><details><p>要注意顺序很重要，用<code>@click.prevent.self</code>会阻止所有的点击，而<code>@click.self.prevent</code>只会阻止对元素自身的点击。</p></details><h3 id="Vue-如何监听键盘事件"><a href="#Vue-如何监听键盘事件" class="headerlink" title="Vue 如何监听键盘事件"></a>Vue 如何监听键盘事件</h3><details><p>使用按键修饰符 <code>&lt;input @keyup.enter=&quot;submit&quot;&gt;</code>按下回车键时候触发 submit 事件</p><ul><li>.enter</li><li>.tab</li><li>.delete (捕获“删除”和“退格”键)</li><li>.esc</li><li>.space</li><li>.up</li><li>.down</li><li>.left</li><li>.right。</li></ul></details><h3 id="v-show-和-v-if-有什么区别？使用场景分别是什么"><a href="#v-show-和-v-if-有什么区别？使用场景分别是什么" class="headerlink" title="v-show 和 v-if 有什么区别？使用场景分别是什么"></a>v-show 和 v-if 有什么区别？使用场景分别是什么</h3><details><ul><li>v-show，切换元素的 display 属性,来控制元素显示隐藏，初始化会渲染，适用频繁显示隐藏的元素,不能用在<code>&lt;template&gt;</code>上；</li><li>v-if，通过销毁并重建组件，来控制组件显示隐藏，初始化不会渲染，不适用频繁显示隐藏的组件，可以用在<code>&lt;template&gt;</code>上。</li></ul></details><h3 id="vm-nextTick-有什么作用"><a href="#vm-nextTick-有什么作用" class="headerlink" title="vm.$nextTick 有什么作用"></a>vm.$nextTick 有什么作用</h3><details><p>vm.$nextTick(() =&gt;{this.handleadd()}),将 handleadd 回调延迟到下次 DOM 更新循环之后执行。</p></details><h3 id="Vue-中怎么重置-data"><a href="#Vue-中怎么重置-data" class="headerlink" title="Vue 中怎么重置 data"></a>Vue 中怎么重置 data</h3><details><p>Object.assign(this.$data,this.$options.data())。</p></details><hr><blockquote><footer><strong>内容来源:</strong><cite><a href="https://juejin.im/post/5d6e6e916fb9a06b1b19dda3#comment" target="_blank" rel="noopener">掘金作者红尘炼心</a></cite></footer></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vue-初级知识汇总&quot;&gt;&lt;a href=&quot;#Vue-初级知识汇总&quot; class=&quot;headerlink&quot; title=&quot;Vue 初级知识汇总&quot;&gt;&lt;/a&gt;Vue 初级知识汇总&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://chenwenkai8023ni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>js深拷贝与浅拷贝</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/2836dd7e.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/2836dd7e.html</id>
    <published>2020-07-23T01:56:45.000Z</published>
    <updated>2020-07-25T03:01:15.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js-深拷贝与浅拷贝"><a href="#js-深拷贝与浅拷贝" class="headerlink" title="js 深拷贝与浅拷贝"></a>js 深拷贝与浅拷贝</h2><a id="more"></a><p>深拷贝与浅拷贝的区别，实现深拷贝的几种方法是面试必问考点<br>区分两者很容易,简单的来说,假设 b 复制了 a,当修改 a 的值时,b 的值也发生变化,这就是浅拷贝<br>如果 b 没有发生改变就是深拷贝<br>浅拷贝例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> B = A;</span><br><span class="line">A[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A, B);</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/07/23/UqNCr9.png" alt="图示"></p><h3 id="基本数据类型与引用数据类型"><a href="#基本数据类型与引用数据类型" class="headerlink" title="基本数据类型与引用数据类型"></a>基本数据类型与引用数据类型</h3><p>1 基本类型–名值存储在栈内存中 let a =1</p><p><img src="https://s1.ax1x.com/2020/07/23/UqduMF.png" alt="图示"><br>当 b=a 复制时,栈内存会重新开辟一个内存<br><img src="https://s1.ax1x.com/2020/07/23/UqdJG6.png" alt="图示"><br>所以此时修改 a=2，对 b 并不会造成影响</p><p>2 引用数据类型–名存在栈内存中，值存在于堆内存中</p><p><img src="https://s1.ax1x.com/2020/07/23/UqdyJP.png" alt="图示"><br>当 b=a 进行拷贝时，其实复制的是 a 的引用地址，而并非堆里面的值。<br><img src="https://s1.ax1x.com/2020/07/23/UqwpJx.png" alt="图示"><br>当我们 a[0]=1 时进行数组修改时，由于 a 与 b 指向的是同一个地址，所以自然 b 也受了影响，这就是所谓的浅拷贝了。<br><img src="https://s1.ax1x.com/2020/07/23/Uqwo0H.png" alt="图示"><br>要是在堆内存中也开辟一个新的内存专门为 b 存放值，就像基本类型那样就达到深拷贝效果<br><img src="https://s1.ax1x.com/2020/07/23/Uq0CAs.png" alt="图示"></p><h4 id="深拷贝方法"><a href="#深拷贝方法" class="headerlink" title="深拷贝方法"></a>深拷贝方法</h4><h5 id="使用递归的方式实现深拷贝"><a href="#使用递归的方式实现深拷贝" class="headerlink" title="使用递归的方式实现深拷贝"></a>使用递归的方式实现深拷贝</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//根据传入参数定义为数组还是镀锡</span></span><br><span class="line">  <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="comment">//for in以任意顺序遍历一个对象的除Symbol以外的可枚举属性。</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="comment">//返回一个布尔值，用来判断某个对象是否含有指定的属性</span></span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="comment">////判断ojb子元素是否为对象，如果是，递归复制</span></span><br><span class="line">        <span class="keyword">if</span> (obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">"object"</span>) &#123;</span><br><span class="line">          objClone[key] = deepClone(obj[key]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          objClone[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"张三"</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  <span class="number">4</span>,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> b = deepClone(a);</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a, b);</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/07/23/ULKNC9.png" alt="图示"><br>跟预想的一样，现在 b 脱离了 a 的控制，不再受 a 影响了</p><h5 id="通过-JSON-对象实现深拷贝"><a href="#通过-JSON-对象实现深拷贝" class="headerlink" title="通过 JSON 对象实现深拷贝"></a>通过 JSON 对象实现深拷贝</h5><p>缺点:<br>JSON 对象实现深拷贝的一些问题.无法实现对对象中方法的深拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone2</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _obj = <span class="built_in">JSON</span>.stringify(obj),</span><br><span class="line">    objClone = <span class="built_in">JSON</span>.parse(_obj);</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="通过-Object-assign-拷贝"><a href="#通过-Object-assign-拷贝" class="headerlink" title="通过 Object.assign()拷贝"></a>通过 Object.assign()拷贝</h6><p>缺点:<br>当对象只有一级属性为深拷贝；<br>当对象中有多级属性时，二级属性后就是浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"张三"</span>,</span><br><span class="line">  info: &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">"男"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将所有可枚举属性的值从一个或多个源对象复制到目标对象。 它将返回目标对象。</span></span><br><span class="line"><span class="keyword">let</span> resobj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">obj[<span class="string">"name"</span>] = <span class="string">"李四"</span>;</span><br><span class="line">obj[<span class="string">"info"</span>][<span class="string">"sex"</span>] = <span class="string">"女"</span>;</span><br><span class="line">obj[<span class="string">"info"</span>][<span class="string">"age"</span>] = <span class="string">"30"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj, resobj);</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/07/23/ULtGsH.png" alt="图示"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;js-深拷贝与浅拷贝&quot;&gt;&lt;a href=&quot;#js-深拷贝与浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;js 深拷贝与浅拷贝&quot;&gt;&lt;/a&gt;js 深拷贝与浅拷贝&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="JS" scheme="https://chenwenkai8023ni.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>面试题总结</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/5c3dbcbd.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/5c3dbcbd.html</id>
    <published>2020-07-21T09:51:35.000Z</published>
    <updated>2020-07-25T03:00:37.135Z</updated>
    
    <content type="html"><![CDATA[<p>只适合(初级)入门前端看看</p><a id="more"></a><h3 id="浏览器如何渲染网页"><a href="#浏览器如何渲染网页" class="headerlink" title="浏览器如何渲染网页"></a>浏览器如何渲染网页</h3><h4 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h4><h5 id="1-HTML-解析，构建-DOM-树"><a href="#1-HTML-解析，构建-DOM-树" class="headerlink" title="1 HTML 解析，构建 DOM 树"></a>1 HTML 解析，构建 DOM 树</h5><p>浏览器从网络或者硬盘中获取 HTML 字节数据经过一下流程将 html 字节解析为 DOM 树</p><ul><li>将原始的 html 字节数据转化为文件制定字符</li><li>然后浏览器会根据 HTML 规范来将字符串转换成各种令牌（如 html、body、p 这样的标签以及标签中的字符串和属性等都会被转化为令牌，每个令牌具有特殊含义和规则）。</li><li>接着每个令牌都会被转换成定义其属性和规则的对象，即节点对象。\</li><li>最后将节点对象构建成树形结构，即 DOM 树。HTML 标签之间有复杂的父子关系，树形结构刚好可以诠释这样的关系。</li></ul><p>接下来通过一段 HTML 代码与配图更好的理解“字节 -&gt; 字符 -&gt; 令牌-&gt; 节点对象 -&gt; 对象模型”这个过程</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"imgs.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/07/21/UowcDI.png" alt="图示"></p><h5 id="2-CSS-解析，构建-CSSOM-树"><a href="#2-CSS-解析，构建-CSSOM-树" class="headerlink" title="2 CSS 解析，构建 CSSOM 树"></a>2 CSS 解析，构建 CSSOM 树</h5><p>浏览器解析遇到 link 标签时，浏览器就开始解析 CSS，像构建 DOM 树一样构建 CSSOM 树。style.css 的代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/07/21/Uo0UMj.png" alt="图示"></p><h5 id="3-Render-Tree"><a href="#3-Render-Tree" class="headerlink" title="3 Render Tree"></a>3 Render Tree</h5><p>在构建了 DOM 树和 CSSOM 树之后，浏览器只是拥有 2 个相互独立的对象集合，DOM 树描述的文档结构和内容，CSSOM 树描述了对应文档的样式规则，想要渲染出页面，就需要将 DOM 树、CSSOM 树结合在一起，构建渲染树。</p><p><img src="https://s1.ax1x.com/2020/07/21/UoBUfO.png" alt="图示"></p><h5 id="4-layout-布局"><a href="#4-layout-布局" class="headerlink" title="4 layout(布局)"></a>4 layout(布局)</h5><p>渲染树构建好后，浏览器得到了每个节点的内容与样式，下一步就是需要计算每个节点在浏览器窗口的确切位置与大小，即 layout 布局。<br>布局阶段，从渲染树的根节点开始遍历，采用盒子模型的模式来表示每个节点与其他元素之间的距离，从而确定每个元素在屏幕内的位置与大小。</p><blockquote><p>盒子模型：包括外边距（margin），内边距（padding），边框（border），内容（content）。标准盒子模型 width/height = content；IE 盒子模型 width/height = content + padding + border。</p></blockquote><p><img src="https://s1.ax1x.com/2020/07/21/UorlZR.png" alt="图示"></p><h5 id="5-只知道流程不知道原理-前端真难"><a href="#5-只知道流程不知道原理-前端真难" class="headerlink" title="5 只知道流程不知道原理.前端真难"></a>5 只知道流程不知道原理.前端真难</h5><h3 id="页面渲染优化"><a href="#页面渲染优化" class="headerlink" title="页面渲染优化"></a>页面渲染优化</h3><h4 id="优化渲染文件"><a href="#优化渲染文件" class="headerlink" title="优化渲染文件"></a>优化渲染文件</h4><h5 id="优化-JS"><a href="#优化-JS" class="headerlink" title="优化 JS"></a>优化 JS</h5><p>JavaScript 文件加载会阻塞 DOM 树的构建，可以给 script 标签添加异步属性 async，这样浏览器的 HTML 解析就不会被 js 文件阻塞。</p><h5 id="优化-CSS"><a href="#优化-CSS" class="headerlink" title="优化 CSS"></a>优化 CSS</h5><p>浏览器每次遇到 link 标签时，浏览器就需要向服务器发出请求获得 CSS 文件，然后才继续构建 DOM 树和 CSSOM 树，可以合并所有 CSS 成一个文件，减少 HTTP 请求，减少关键资源往返加载的时间，优化渲染速度。</p><h5 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h5><p>对 HTML、CSS、JavaScript 这些文件去除冗余字符（例如不必要的注释、空格符和换行符等），再进行压缩，减小文件数据大小，加快浏览器解析文件编码。</p><h5 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h5><p>图片加载较多时，采用懒加载的方案，用户滚动页面可视区时再加载渲染图片</p><h3 id="JS-继承"><a href="#JS-继承" class="headerlink" title="JS 继承"></a>JS 继承</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">10</span>; <span class="comment">//添加原型属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"张三"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Person(); <span class="comment">//将Son原型指向父类实例</span></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(); <span class="comment">//实例的原型指向父类实例</span></span><br><span class="line">son.name = <span class="string">"张三"</span>;</span><br><span class="line">son.age = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 使用instanceof判断元素是否在另一个元素的原型链上;</span></span><br><span class="line">son <span class="keyword">instanceof</span> Person; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>特点<ul><li>son 实例可继承的属性有</li><li>实例的构造函数的属性</li><li>父类的构造函数属性</li><li>父类原型的属性</li><li>但不会继承父类实例上的属性</li></ul></li><li>缺点<ul><li>son 实例无法向父类构造函数传参</li><li>所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）</li></ul></li></ul><h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, <span class="string">"张三"</span>);</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son();</span><br><span class="line">son.name = <span class="string">"张三"</span>;</span><br><span class="line">son <span class="keyword">instanceof</span> Person; <span class="comment">//fasle</span></span><br></pre></td></tr></table></figure><ul><li>特点<ul><li>只继承了父类构造函数的属性，没有继承父类原型的属性。</li><li>解决了原型链继承缺点</li><li>在子实例中可向父实例传参</li></ul></li><li>缺点<ul><li>只能继承父类构造函数的属性</li><li>无法实现构造函数的复用。（每次用每次都要重新调用）</li><li>每个新实例都有父类构造函数的副本，臃肿。</li></ul></li></ul><h4 id="组合继承（组合原型链继承和借用构造函数继承）"><a href="#组合继承（组合原型链继承和借用构造函数继承）" class="headerlink" title="组合继承（组合原型链继承和借用构造函数继承）"></a>组合继承（组合原型链继承和借用构造函数继承）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">"张三"</span>);</span><br><span class="line">son.name = <span class="string">"张三"</span>;</span><br></pre></td></tr></table></figure><ul><li>特点<ul><li>可以继承父类原型上的属性，可以传参，可复用。</li><li>每个新实例引入的构造函数属性是私有的。</li></ul></li><li>缺点<ul><li>调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</li></ul></li></ul><blockquote><p>还有很多种继承方式.写多了也记不住,等理解完了再补</p></blockquote><h3 id="JS-中-new-一个对象时到底发生了什么"><a href="#JS-中-new-一个对象时到底发生了什么" class="headerlink" title="JS 中 new 一个对象时到底发生了什么"></a>JS 中 new 一个对象时到底发生了什么</h3><p>创建一个 Person 的实例,必须使用到 new 操作符.以这种方式调用构造函数实际上会经历以下 4 个步骤：</p><ul><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象。<br><strong>new 操作符</strong><br>在有上面的基础概念的介绍之后，在加上 new 操作符，我们就能完成传统面向对象的 class + new 的方式创建对象，在 JavaScript 中，我们将这类方式成为 Pseudoclassical。<br>基于上面的例子，我们执行如下代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Base();</span><br></pre></td></tr></table></figure><p>这样代码的结果是什么，我们在 Javascript 引擎中看到的对象模型是：<br><img src="https://s1.ax1x.com/2020/07/22/U79I8s.png" alt="图示"><br>如图所示 new 操作符干了三件事</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure><p>第一行，我们创建了一个空对象 obj<br>第二行，我们将这个空对象的__proto__成员指向了 Base 函数对象 prototype 成员对象<br>第三行，我们将 Base 函数对象的 this 指针替换成 obj，然后再调用 Base 函数，<br>于是我们就给 obj 对象赋值了一个 id 成员变量，这个成员变量的值是 base</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base.prototype.tostring = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们 Base 原型添加一些方法,那么 new 出来的实例对象,根据__proto__的特性也能够使用 tostring 方法</p><p>下面的例子中分别通过构造函数与 class 类实现了一个简单的创建实例的过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5构造函数</span></span><br><span class="line"><span class="keyword">let</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Parent(<span class="string">"一晌贪欢"</span>, <span class="number">25</span>);</span><br><span class="line">child.sayName(); <span class="comment">//'一晌贪欢'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 class类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Parent(<span class="string">"echo"</span>, <span class="number">25</span>);</span><br><span class="line">child.sayName(); <span class="comment">//echo</span></span><br></pre></td></tr></table></figure><h4 id="new-操作中发生了什么"><a href="#new-操作中发生了什么" class="headerlink" title="new 操作中发生了什么"></a>new 操作中发生了什么</h4><p>在《JavaScript 模式》这本书中，new 的过程说的比较直白，当我们 new 一个构造器，主要有三步：</p><ul><li>创建一个空对象，将它的引用赋给 this，继承函数的原型。</li><li>通过 this 将属性和方法添加至这个对象</li><li>最后返回 this 指向的新对象，也就是实例（如果没有手动返回其他的对象）</li></ul><p>改写上面的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5构造函数</span></span><br><span class="line"><span class="keyword">let</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1.创建一个新对象，赋予this，这一步是隐性的，</span></span><br><span class="line">  <span class="comment">// let this = &#123;&#125;;</span></span><br><span class="line">  <span class="comment">//2.给this指向的对象赋予构造属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="comment">//3.如果没有手动返回对象，则默认返回this指向的这个对象，也是隐性的</span></span><br><span class="line">  <span class="comment">// return this;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><h4 id="实现一个简单的-new-方法"><a href="#实现一个简单的-new-方法" class="headerlink" title="实现一个简单的 new 方法"></a>实现一个简单的 new 方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器函数</span></span><br><span class="line"><span class="keyword">let</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自己定义的new方法</span></span><br><span class="line"><span class="keyword">let</span> newMethod = <span class="function"><span class="keyword">function</span> (<span class="params">Parent, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.以构造器的prototype属性为原型，创建新对象；</span></span><br><span class="line">  <span class="keyword">let</span> child = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">  <span class="comment">// 2.将this和调用参数传给构造器执行</span></span><br><span class="line">  Parent.apply(child, rest);</span><br><span class="line">  <span class="comment">// 3.返回第一步的对象</span></span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建实例，将构造函数Parent与形参作为参数传入</span></span><br><span class="line"><span class="keyword">const</span> child = newMethod(Parent, <span class="string">"echo"</span>, <span class="number">26</span>);</span><br><span class="line">child.sayName(); <span class="comment">//'echo';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后检验，与使用new的效果相同</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent; <span class="comment">//true</span></span><br><span class="line">child.hasOwnProperty(<span class="string">"name"</span>); <span class="comment">//true</span></span><br><span class="line">child.hasOwnProperty(<span class="string">"age"</span>); <span class="comment">//true</span></span><br><span class="line">child.hasOwnProperty(<span class="string">"sayName"</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><h4 id="什么是-Vuex"><a href="#什么是-Vuex" class="headerlink" title="什么是 Vuex"></a>什么是 Vuex</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理插件。它采用集中式存储管理应用的所有组件的状态，而更改状态的唯一方法是提交 mutation，例 this.$store.commit(‘SET_VIDEO_PAUSE’, video_pause，SET_VIDEO_PAUSE 为 mutations 属性中定义的方法</p><h4 id="什么时候使用"><a href="#什么时候使用" class="headerlink" title="什么时候使用"></a>什么时候使用</h4><ul><li>多个组件依赖于同一状态时。</li><li>来自不同组件的行为需要变更同一状态。</li></ul><h4 id="Vuex-的-5-个核心属性是什么"><a href="#Vuex-的-5-个核心属性是什么" class="headerlink" title="Vuex 的 5 个核心属性是什么"></a>Vuex 的 5 个核心属性是什么</h4><p>state、getters、mutations、actions、modules</p><h4 id="Vuex-中状态储存在哪里，怎么改变它"><a href="#Vuex-中状态储存在哪里，怎么改变它" class="headerlink" title="Vuex 中状态储存在哪里，怎么改变它"></a>Vuex 中状态储存在哪里，怎么改变它</h4><p>存储在 state 中，改变 Vuex 中的状态的唯一途径就是显式地提交 (commit) mutation。</p><h4 id="怎么在组件中批量使用-Vuex-的-state-状态"><a href="#怎么在组件中批量使用-Vuex-的-state-状态" class="headerlink" title="怎么在组件中批量使用 Vuex 的 state 状态"></a>怎么在组件中批量使用 Vuex 的 state 状态</h4><p>使用 mapState 辅助函数, 利用对象展开运算符将 state 混入 computed 对象中</p><h4 id="Vuex-中-action-和-mutation-有什么区别"><a href="#Vuex-中-action-和-mutation-有什么区别" class="headerlink" title="Vuex 中 action 和 mutation 有什么区别"></a>Vuex 中 action 和 mutation 有什么区别</h4><ul><li>action 提交的是 mutation，而不是直接变更状态。mutation 可以直接变更状态。</li><li>action 可以包含任意异步操作。mutation 只能是同步操作。</li><li>提交方式不同，action 是用 this.$store.dispatch(‘ACTION_NAME’,data)来提交。mutation是用this.$store.commit(‘SET_NUMBER’,10)来提交。</li></ul><h3 id="vue-中-router-与-route-的区别"><a href="#vue-中-router-与-route-的区别" class="headerlink" title="vue 中 router 与 route 的区别"></a>vue 中 router 与 route 的区别</h3><blockquote><p>router 是 VueRouter 的一个对象，通过 Vue.use(VueRouter)和 VueRouter 构造函数得到一个 router 的实例对象,他包含了所有的路由包含了许多关键的对象和属性<br>route 是一个跳转的路由对象，每一个路由都会有一个 route 对象，是一个局部的对象，可以获取对应的 name,path,params,query 等</p></blockquote><ul><li><p>$route.path</p><ul><li>字符串，等于当前路由对象的路径，会被解析为绝对路径，如 “/home/news” 。</li></ul></li><li><p>$route.params</p><ul><li>对象，包含路由中的动态片段和全匹配片段的键值对</li></ul></li><li><p>$route.query</p><ul><li>对象，包含路由中查询参数的键值对。例如，对于 /home/news/detail/01?favorite=yes ，会得到$route.query.favorite == ‘yes’ 。</li></ul></li><li><p>$route.router</p><ul><li>路由规则所属的路由器（以及其所属的组件）。</li></ul></li><li><p>$route.matched</p><ul><li>数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</li></ul></li><li><p>$route.name</p><ul><li>当前路径的名字，如果没有使用具名路径，则名字为空。</li></ul></li><li><p>$route.path, $route.params, $route.name, $route.query 这几个属性，主要用于接收路由传递的参数</p></li></ul><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="监听和计算属性的区别"><a href="#监听和计算属性的区别" class="headerlink" title="监听和计算属性的区别"></a>监听和计算属性的区别</h4><h5 id="computed-特性"><a href="#computed-特性" class="headerlink" title="computed 特性"></a>computed 特性</h5><ul><li>计算值</li><li>就是简化 tempalte 里面计算和处理 props 或$emit 的传值</li><li>具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数</li><li>计算属性还可以依赖多个 Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新。</li></ul><h5 id="watch-特性"><a href="#watch-特性" class="headerlink" title="watch 特性"></a>watch 特性</h5><ul><li>观察的动作</li><li>监听 props，$emit 或本组件的值执行异步操作</li><li>无缓存性，页面重新渲染时值不变化也会执行</li></ul><h4 id="生命周期有哪些"><a href="#生命周期有哪些" class="headerlink" title="生命周期有哪些"></a>生命周期有哪些</h4><ul><li>beforeCreate：实例创建前被调用；</li><li>created：实例创建后被调用，完成数据观测，属性和方法的运算，watch/event 事件回调，模板渲染成 html 前（vm.$el 未定义）故数据初始化最好在这阶段完成；</li><li>beforeMount：在$el 挂载前被调用，相关的 render 函数首次被调用，期间将模块渲染成 html,此时 vm.$el 还是未定义；</li><li>mounted：在$el 挂载后被调用，此时 vm.$el 可以调用，不能保证所有的子组件都挂载，要等视图全部更新完毕用 vm.$nextTick();</li><li>beforeUpdate：数据更新时调用;</li><li>updated：数据更新后调用;</li><li>activated：keep-alive/keep-alive 包裹的组件激活时调用；</li><li>deactivated:keep-alive 包裹的组件离开时调用；keep-alive 包裹的组件离开时调用；</li><li>beforeDestroy:实例销毁之前调用,此时实例仍然完全可用；</li><li>destroyed：实例销毁之后调用,此时实例的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul><h4 id="vue-常用指令"><a href="#vue-常用指令" class="headerlink" title="vue 常用指令"></a>vue 常用指令</h4><ul><li><p><code>v-show</code>，切换元素的 display 属性,来控制元素显示隐藏，初始化会渲染，适用频繁显示隐藏的元素,不能用在 template 上；</p></li><li><p><code>v-if</code>，通过销毁并重建组件，来控制组件显示隐藏，初始化不会渲染，不适用频繁显示隐藏的组件，可以用在 template 上</p></li><li><p><code>v-else-if</code>，必须和 <code>v-if</code> 一起使用</p></li><li><p><code>v-else</code>，必须和 <code>v-if</code> 一起使用；</p></li><li><p><code>v-for</code>，将 Array、Object、Number、String 数据循环渲染元素或者组件，渲染组件必须带上 key，key 要为数据中每项特定值比如 ID；</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in Array"</span>&gt;</span>&#123;&#123;index&#125;&#125;-&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item,key,index) in Object"</span>&gt;</span>&#123;&#123;index&#125;&#125;-&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in Number"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in String"</span>&gt;</span>&#123;&#123;index&#125;&#125;-&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">myVue</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"(item,key,index) in Object"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:title</span>=<span class="string">"item.title"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:key</span>=<span class="string">"item.id"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">myVue</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>v-on</code>，缩写@，监听事件，如：@click、@submit、@dblclick</p><ul><li>怎么获取 div 上点击的鼠标位置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=<span class="string">"a"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div @click="b(1,2,$event)"&gt;&lt;/</span>div&gt;</span><br><span class="line">methods:&#123;</span><br><span class="line">  a()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(event.clientX,event.clientY)</span><br><span class="line">  &#125;,</span><br><span class="line">  b(num1,num2,$event)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log($event.clientX,$event.clientY)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>怎么阻止冒泡，怎么阻止默认事件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//阻止冒泡</span></span><br><span class="line">&lt;div @click.stop=<span class="string">"a"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/阻止默认</span></span><br><span class="line"><span class="regexp">&lt;div @click.prevent="b"&gt;&lt;/</span>div&gt;</span><br><span class="line"><span class="comment">//阻止冒泡阻止默认</span></span><br><span class="line">&lt;div @click.stop.prevent=<span class="string">"c"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><ul><li>监听组件根元素的原生事件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">myVue</span> @<span class="attr">click.native</span>=<span class="string">"d"</span>&gt;</span><span class="tag">&lt;/<span class="name">myVue</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>监听组件自定义事件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">myVue</span> @<span class="attr">diy-event</span>=<span class="string">"f"</span>&gt;</span><span class="tag">&lt;/<span class="name">myVue</span>&gt;</span> //组件中这样触发 this.$emit('diyEvent',data)</span><br></pre></td></tr></table></figure></li><li><p>v-bind，缩写:,绑定动态属性；</p></li><li><p>v-model，限制应用在 input textarea select 表单 元素和组件上创建双向绑定，修饰符 v-model.lazy 懒监听、v-model.number 将值转成有效的数字、v-model.trim 过滤首尾空格；</p></li><li><p>v-text，<code>&lt;div v-text=&quot;data&quot;&gt;&lt;/div&gt;等同&lt;div&gt;&lt;/div&gt;</code></p></li><li><p>v-html，直接输出 HTML，不会按 Vue 模板编译，会有 XSS 攻击分析，不要用在用户提交内容上；</p></li></ul><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><ul><li>计算属性有什么特性？</li></ul><p>计算属性是基于它们的响应式依赖进行缓存的,只在相关响应式依赖发生改变时它们才会重新求值。</p><ul><li><p>计算属性的 getter 和 setter 是什么，有什么用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; a &#125;&#125;&lt;&#x2F;span</span><br><span class="line">    &gt;&lt;span&gt;加&lt;&#x2F;span&gt;&lt;span&gt;&#123;&#123; b &#125;&#125;&lt;&#x2F;span</span><br><span class="line">    &gt;&lt;span&gt;等于&lt;&#x2F;span&gt;&lt;span&gt;&#123;&#123; c &#125;&#125;&lt;&#x2F;span&gt; &lt;span&gt;&#123;&#123; a &#125;&#125;&lt;&#x2F;span</span><br><span class="line">    &gt;&lt;span&gt;乘&lt;&#x2F;span&gt;&lt;span&gt;&#123;&#123; b &#125;&#125;&lt;&#x2F;span</span><br><span class="line">    &gt;&lt;span&gt;等于&lt;&#x2F;span&gt;&lt;span&gt;&#123;&#123; d &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;add&quot;&gt;加1&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      a: 1,</span><br><span class="line">      b: 2,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    c: function () &#123;</span><br><span class="line">      return this.a + this.b;</span><br><span class="line">    &#125;,</span><br><span class="line">    d: &#123;</span><br><span class="line">      get: function () &#123;</span><br><span class="line">        return this.a * this.b;</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function (val) &#123;</span><br><span class="line">        this.a &#x3D; val &#x2F; this.b;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add() &#123;</span><br><span class="line">      this.d &#x3D; this.d * 2;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Vue-中操作-data-中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法"><a href="#Vue-中操作-data-中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法" class="headerlink" title="Vue 中操作 data 中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法"></a>Vue 中操作 data 中数组的方法中哪些可以触发视图更新，哪些不可以，不可以的话有什么解决办法</h4><p>push()、pop()、shift()、unshift()、splice()、sort()、reverse()这些方法会改变被操作的数组；<br>filter()、concat()、slice()这些方法不会改变被操作的数组，返回一个新的数组；<br>以上方法都可以触发视图更新。</p><ul><li><p>利用索引直接设置一个数组项，例：this.array[index] = newValue</p></li><li><p>直接修改数组的长度，例：this.array.length = newLength</p></li></ul><p>以上两种方法不可以触发视图更新</p><ul><li>可以用 this.$set(this.array,index,newValue)或 this.array.splice(index,1,newValue)解决方法 1</li><li>可以用 this.array.splice(newLength)解决方法 2</li></ul><h4 id="v-for-和-v-if-能共同使用吗"><a href="#v-for-和-v-if-能共同使用吗" class="headerlink" title="v-for 和 v-if 能共同使用吗"></a>v-for 和 v-if 能共同使用吗</h4><p>在处于同一节点上，因为 v-for 的优先级比 v-if 更高，v-if 将分别重复运行于每个 v-for 循环中。如果要实现渲染满足条件的 li 节点时，可以这样用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-if</span>=<span class="string">"item.show"</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="父子组件怎么通信"><a href="#父子组件怎么通信" class="headerlink" title="父子组件怎么通信"></a>父子组件怎么通信</h4><ul><li><p>父组件到子组件的通信用 props 来完成。</p></li><li><p>子组件到父组件的通信，通过在父组件中自定义事件，在子组件用 this.$emit(‘父组件自定义事件’,’要传到父组件的数据’)实现</p></li><li><p>使用$bus 方法实现组件通信</p></li></ul><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick()"></a>$nextTick()</h4><ul><li>参数为 callback，等待视图全部更新后执行，回调函数的 this 自动绑定到调用它的实例上；</li></ul><h4 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;my-component v-model&#x3D;&quot;value&quot;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">    &lt;!-- 等同 --&gt;</span><br><span class="line">    &lt;my-component :value&#x3D;&quot;value&quot; @input&#x3D;&quot;value &#x3D; $event&quot;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;value &#x3D; true&quot;&gt;显示&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      value: false,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    myComponent: (resolve) &#x3D;&gt; require([&quot;.&#x2F;my_component&quot;], resolve),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-show&#x3D;&quot;value&quot;&gt;</span><br><span class="line">    &lt;span&gt;我的组件&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;$emit(&#39;input&#39;, false)&quot;&gt;隐藏&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="let-造成块级作用域的原因"><a href="#let-造成块级作用域的原因" class="headerlink" title="let 造成块级作用域的原因"></a>let 造成块级作用域的原因</h3><p>空</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次面试让我知道了自己几斤几两.</p><blockquote><p>参考链接 <a href="https://juejin.im/post/5d136700f265da1b7c6128db" target="_blank" rel="noopener">https://juejin.im/post/5d136700f265da1b7c6128db</a><br>参考链接 <a href="https://www.cnblogs.com/ranyonsue/p/11201730.html" target="_blank" rel="noopener">https://www.cnblogs.com/ranyonsue/p/11201730.html</a><br>参考链接 <a href="https://blog.csdn.net/qq_27674439/article/details/99095336" target="_blank" rel="noopener">https://blog.csdn.net/qq_27674439/article/details/99095336</a><br>参考链接 <a href="https://juejin.im/post/5dba91e4518825647e4ef18b" target="_blank" rel="noopener">https://juejin.im/post/5dba91e4518825647e4ef18b</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只适合(初级)入门前端看看&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web" scheme="https://chenwenkai8023ni.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>canvas实现贪吃蛇</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/f47fe538.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/f47fe538.html</id>
    <published>2020-07-20T01:59:57.000Z</published>
    <updated>2020-07-25T03:00:57.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="canvas-实现简易贪吃蛇"><a href="#canvas-实现简易贪吃蛇" class="headerlink" title="canvas 实现简易贪吃蛇"></a>canvas 实现简易贪吃蛇</h2><a id="more"></a><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ul><li>制作蛇<ul><li>蛇头和蛇身</li><li>蛇运动</li></ul></li><li>键盘事件<ul><li>animate 运动</li><li>随机食物</li></ul></li><li>随机数坐标<ul><li>是否投放在蛇身和蛇头中(重新投放)</li><li>吃食物</li></ul></li><li>碰撞检测<ul><li>增加蛇身长度</li><li>蛇头是否碰撞到蛇身</li><li>gameover</li></ul></li></ul><h3 id="定义绘制矩形构造函数"><a href="#定义绘制矩形构造函数" class="headerlink" title="定义绘制矩形构造函数"></a>定义绘制矩形构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Reat</span>(<span class="params">x, y, width, height, color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.fillStyle = <span class="keyword">this</span>.color;</span><br><span class="line">    ctx.fillRect(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line">    ctx.strokeRect(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line"><span class="comment">//吃食物开关</span></span><br><span class="line"><span class="keyword">let</span> isEatFood = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//定时器</span></span><br><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"><span class="comment">//速度</span></span><br><span class="line"><span class="keyword">let</span> sudu = <span class="number">200</span>;</span><br><span class="line"><span class="comment">//键盘值</span></span><br><span class="line"><span class="keyword">let</span> keycode = <span class="number">39</span>;</span><br><span class="line"><span class="comment">//定时器开关</span></span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//食物方法</span></span><br><span class="line"><span class="keyword">let</span> food;</span><br><span class="line"><span class="comment">//蛇实例</span></span><br><span class="line"><span class="keyword">let</span> snake;</span><br></pre></td></tr></table></figure><h3 id="定义蛇构造函数"><a href="#定义蛇构造函数" class="headerlink" title="定义蛇构造函数"></a>定义蛇构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Snake</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//初始化蛇运动方向</span></span><br><span class="line">  <span class="keyword">this</span>.direction = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//蛇头</span></span><br><span class="line">  <span class="keyword">this</span>.head = <span class="keyword">new</span> Reat(</span><br><span class="line">    canvas.width / <span class="number">2</span> - <span class="number">20</span>,</span><br><span class="line">    canvas.height / <span class="number">2</span> - <span class="number">20</span>,</span><br><span class="line">    <span class="number">40</span>,</span><br><span class="line">    <span class="number">40</span>,</span><br><span class="line">    <span class="string">"red"</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//蛇身</span></span><br><span class="line">  <span class="keyword">this</span>.body = [];</span><br><span class="line">  <span class="keyword">let</span> x = <span class="keyword">this</span>.head.x - <span class="number">40</span>;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="keyword">this</span>.head.y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> rect = <span class="keyword">new</span> Reat(x, y, <span class="number">40</span>, <span class="number">40</span>, <span class="string">"gray"</span>);</span><br><span class="line">    <span class="keyword">this</span>.body.push(rect);</span><br><span class="line">    x -= <span class="number">40</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//画</span></span><br><span class="line">  <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 绘制蛇头</span></span><br><span class="line">    <span class="keyword">this</span>.head.draw();</span><br><span class="line">    <span class="comment">//绘制蛇身</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.body.length; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.body[i].draw();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 移动</span></span><br><span class="line">  <span class="keyword">this</span>.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建当前蛇头位置的蛇身</span></span><br><span class="line">    <span class="keyword">let</span> rect = <span class="keyword">new</span> Reat(</span><br><span class="line">      <span class="keyword">this</span>.head.x,</span><br><span class="line">      <span class="keyword">this</span>.head.y,</span><br><span class="line">      <span class="keyword">this</span>.head.width,</span><br><span class="line">      <span class="keyword">this</span>.head.height,</span><br><span class="line">      <span class="string">"gray"</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.body.splice(<span class="number">0</span>, <span class="number">0</span>, rect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去尾</span></span><br><span class="line">    <span class="comment">//如何没吃到食物,去除一个尾部</span></span><br><span class="line">    <span class="keyword">if</span> (isEatFood == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.body.pop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isEatFood = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//蛇头移动</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.direction) &#123;</span><br><span class="line">      <span class="comment">//蛇头向左</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head.x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.head.x = canvas.width;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.head.x -= <span class="keyword">this</span>.head.width;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//上</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head.y &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.head.y = canvas.height;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.head.y -= <span class="keyword">this</span>.head.width;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//右</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head.x &gt;= <span class="number">795</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.head.x = <span class="number">-40</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.head.x += <span class="keyword">this</span>.head.width;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//下</span></span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head.y &gt;= canvas.height - <span class="number">40</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.head.y = <span class="number">-40</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.head.y += <span class="keyword">this</span>.head.width;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断蛇头和蛇身是否撞上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.body.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRect(<span class="keyword">this</span>.head, <span class="keyword">this</span>.body[i])) &#123;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义键盘事件"><a href="#定义键盘事件" class="headerlink" title="定义键盘事件"></a>定义键盘事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//键盘事件传值</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"keydown"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ev = event || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">switch</span> (ev.keyCode) &#123;</span><br><span class="line">    <span class="comment">//左</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">37</span>: &#123;</span><br><span class="line">      <span class="keyword">if</span> (keycode !== <span class="number">39</span>) &#123;</span><br><span class="line">        snake.direction = <span class="number">0</span>;</span><br><span class="line">        keycode = <span class="number">37</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">38</span>: &#123;</span><br><span class="line">      <span class="keyword">if</span> (keycode !== <span class="number">40</span>) &#123;</span><br><span class="line">        snake.direction = <span class="number">1</span>;</span><br><span class="line">        keycode = <span class="number">38</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">39</span>: &#123;</span><br><span class="line">      <span class="keyword">if</span> (keycode !== <span class="number">37</span>) &#123;</span><br><span class="line">        snake.direction = <span class="number">2</span>;</span><br><span class="line">        keycode = <span class="number">39</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">40</span>: &#123;</span><br><span class="line">      <span class="keyword">if</span> (keycode !== <span class="number">38</span>) &#123;</span><br><span class="line">        snake.direction = <span class="number">3</span>;</span><br><span class="line">        keycode = <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="定义食物事件"><a href="#定义食物事件" class="headerlink" title="定义食物事件"></a>定义食物事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">food = isfood();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isfood</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isSnake = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (isSnake) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = getNum(<span class="number">0</span>, (canvas.width - <span class="number">40</span>) / <span class="number">40</span>) * <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">let</span> y = getNum(<span class="number">0</span>, (canvas.height - <span class="number">40</span>) / <span class="number">40</span>) * <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">var</span> rect = <span class="keyword">new</span> Reat(x, y, <span class="number">40</span>, <span class="number">40</span>, <span class="string">"blue"</span>);</span><br><span class="line">    <span class="comment">//判断生成位置是否与蛇头重叠</span></span><br><span class="line">    <span class="keyword">if</span> (isRect(snake.head, rect)) &#123;</span><br><span class="line">      isSnake = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    isSnake = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//判断生成位置是否与蛇身重叠</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; snake.body.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRect(snake.body[i], rect)) &#123;</span><br><span class="line">        isSnake = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机数事件"><a href="#随机数事件" class="headerlink" title="随机数事件"></a>随机数事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random() * (max - min) + min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="碰撞检测事件"><a href="#碰撞检测事件" class="headerlink" title="碰撞检测事件"></a>碰撞检测事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRect</span>(<span class="params">rect1, rect2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> minX1 = rect1.x;</span><br><span class="line">  <span class="keyword">let</span> minX2 = rect2.x;</span><br><span class="line">  <span class="keyword">let</span> minY1 = rect1.y;</span><br><span class="line">  <span class="keyword">let</span> minY2 = rect2.y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> maxX1 = rect1.x + rect1.width;</span><br><span class="line">  <span class="keyword">let</span> maxX2 = rect2.x + rect2.width;</span><br><span class="line">  <span class="keyword">let</span> maxY1 = rect1.y + rect1.height;</span><br><span class="line">  <span class="keyword">let</span> maxY2 = rect2.y + rect2.height;</span><br><span class="line">  <span class="comment">//判断矩形相交</span></span><br><span class="line">  <span class="keyword">let</span> minX = <span class="built_in">Math</span>.max(minX1, minX2);</span><br><span class="line">  <span class="keyword">let</span> minY = <span class="built_in">Math</span>.max(minY1, minY2);</span><br><span class="line">  <span class="keyword">let</span> maxX = <span class="built_in">Math</span>.min(maxX1, maxX2);</span><br><span class="line">  <span class="keyword">let</span> maxY = <span class="built_in">Math</span>.min(maxY1, maxY2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (minX &lt; maxX &amp;&amp; minY &lt; maxY) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">  food.draw(); <span class="comment">//绘制食物</span></span><br><span class="line">  snake.move(); <span class="comment">//蛇头移动坐标</span></span><br><span class="line">  snake.draw(); <span class="comment">//绘制</span></span><br><span class="line">  <span class="comment">//判读蛇头是否吃到食物</span></span><br><span class="line">  <span class="keyword">if</span> (isRect(snake.head, food)) &#123;</span><br><span class="line">    isEatFood = <span class="literal">true</span>;</span><br><span class="line">    food = isfood();</span><br><span class="line">    food.draw();</span><br><span class="line">    sudu = sudu &lt; <span class="number">50</span> ? <span class="number">50</span> : sudu - <span class="number">10</span>;</span><br><span class="line">    stop();</span><br><span class="line">    start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开始游戏计时器"><a href="#开始游戏计时器" class="headerlink" title="开始游戏计时器"></a>开始游戏计时器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">    timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      animate();</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;, sudu);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="暂停游戏"><a href="#暂停游戏" class="headerlink" title="暂停游戏"></a>暂停游戏</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  clearInterval(timer);</span><br><span class="line">  flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;canvas-实现简易贪吃蛇&quot;&gt;&lt;a href=&quot;#canvas-实现简易贪吃蛇&quot; class=&quot;headerlink&quot; title=&quot;canvas 实现简易贪吃蛇&quot;&gt;&lt;/a&gt;canvas 实现简易贪吃蛇&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="WebGL" scheme="https://chenwenkai8023ni.github.io/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>canvas添加样式和颜色</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/6cc1dae0.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/6cc1dae0.html</id>
    <published>2020-07-11T14:10:13.000Z</published>
    <updated>2020-07-25T03:01:00.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="色彩-Colors"><a href="#色彩-Colors" class="headerlink" title="色彩 Colors"></a>色彩 Colors</h2><a id="more"></a><p><code>fillStyle = color</code>设置图形的填充颜色。<br><code>strokeStyle = color</code>设置图形轮廓的颜色<br>color 可以表示为 css 颜色值得字符串,渐变对象,或者图像对象默认都是黑色.重复赋值,新的生效</p><!-- ![图示](https://s1.ax1x.com/2020/07/12/U3MuL9.jpg) --><h2 id="透明度-Transparency"><a href="#透明度-Transparency" class="headerlink" title="透明度 Transparency"></a>透明度 Transparency</h2><p>通过设置 globalAlpha 属性或者使用一个 rgba 设置透明度</p><p>这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。</p><p>globalAlpha 属性在需要绘制大量拥有相同透明度的图形时候相当高效。</p><h3 id="globalAlpha-示例"><a href="#globalAlpha-示例" class="headerlink" title="globalAlpha 示例"></a>globalAlpha 示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>).getContext(<span class="string">"2d"</span>);</span><br><span class="line">  <span class="comment">// 画背景</span></span><br><span class="line">  ctx.fillStyle = <span class="string">"#FD0"</span>;</span><br><span class="line">  ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">75</span>, <span class="number">75</span>);</span><br><span class="line">  ctx.fillStyle = <span class="string">"#6C0"</span>;</span><br><span class="line">  ctx.fillRect(<span class="number">75</span>, <span class="number">0</span>, <span class="number">75</span>, <span class="number">75</span>);</span><br><span class="line">  ctx.fillStyle = <span class="string">"#09F"</span>;</span><br><span class="line">  ctx.fillRect(<span class="number">0</span>, <span class="number">75</span>, <span class="number">75</span>, <span class="number">75</span>);</span><br><span class="line">  ctx.fillStyle = <span class="string">"#F30"</span>;</span><br><span class="line">  ctx.fillRect(<span class="number">75</span>, <span class="number">75</span>, <span class="number">75</span>, <span class="number">75</span>);</span><br><span class="line">  ctx.fillStyle = <span class="string">"#FFF"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置透明度值</span></span><br><span class="line">  ctx.globalAlpha = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 画半透明圆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(<span class="number">75</span>, <span class="number">75</span>, <span class="number">10</span> + <span class="number">10</span> * i, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">    ctx.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rgba-示例"><a href="#rgba-示例" class="headerlink" title="rgba() 示例"></a>rgba() 示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>).getContext(<span class="string">"2d"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 画背景</span></span><br><span class="line">  ctx.fillStyle = <span class="string">"rgb(255,221,0)"</span>;</span><br><span class="line">  ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">37.5</span>);</span><br><span class="line">  ctx.fillStyle = <span class="string">"rgb(102,204,0)"</span>;</span><br><span class="line">  ctx.fillRect(<span class="number">0</span>, <span class="number">37.5</span>, <span class="number">150</span>, <span class="number">37.5</span>);</span><br><span class="line">  ctx.fillStyle = <span class="string">"rgb(0,153,255)"</span>;</span><br><span class="line">  ctx.fillRect(<span class="number">0</span>, <span class="number">75</span>, <span class="number">150</span>, <span class="number">37.5</span>);</span><br><span class="line">  ctx.fillStyle = <span class="string">"rgb(255,51,0)"</span>;</span><br><span class="line">  ctx.fillRect(<span class="number">0</span>, <span class="number">112.5</span>, <span class="number">150</span>, <span class="number">37.5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 画半透明矩形</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    ctx.fillStyle = <span class="string">"rgba(255,255,255,"</span> + (i + <span class="number">1</span>) / <span class="number">10</span> + <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">      ctx.fillRect(<span class="number">5</span> + i * <span class="number">14</span>, <span class="number">5</span> + j * <span class="number">37.5</span>, <span class="number">14</span>, <span class="number">27.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线型-Line-styles"><a href="#线型-Line-styles" class="headerlink" title="线型 Line styles"></a>线型 Line styles</h2><p><code>lineWidth = value</code><br>设置线条宽度。<br><code>lineCap = type</code><br>设置线条末端样式。<br><code>lineJoin = type</code><br>设定线条与线条间接合处的样式。<br><code>miterLimit = value</code><br>限制当两条线相交时交接处最大长度；线条交接处内角顶点到外角顶点的长度。<br><code>getLineDash()</code><br>返回一个包含当前虚线样式，长度为非负偶数的数组。<br><code>setLineDash(segments)</code><br>设置当前虚线样式。<br><code>lineDashOffset = value</code><br>设置虚线样式的起始偏移量。</p><h3 id="lineWidth-属性的例子"><a href="#lineWidth-属性的例子" class="headerlink" title="lineWidth 属性的例子"></a>lineWidth 属性的例子</h3><p>这个属性设置当前绘线的粗细。属性值必须为正数。默认值是 1.0。线宽是指给定路径的中心到两边的粗细。<br><img src="https://mdn.mozillademos.org/files/239/Canvas_linewidth.png" alt="图示"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>).getContext(<span class="string">"2d"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    ctx.lineWidth = <span class="number">1</span> + i;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(<span class="number">5</span> + i * <span class="number">14</span>, <span class="number">5</span>);</span><br><span class="line">    ctx.lineTo(<span class="number">5</span> + i * <span class="number">14</span>, <span class="number">140</span>);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lineCap-属性的例子"><a href="#lineCap-属性的例子" class="headerlink" title="lineCap 属性的例子"></a>lineCap 属性的例子</h3><p>属性 lineCap 的值决定了线段端点显示的样子。它可以为下面的三种的其中之一：butt，round 和 square。默认是 butt。<br><img src="https://mdn.mozillademos.org/files/236/Canvas_linecap.png" alt="图示"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>).getContext(<span class="string">"2d"</span>);</span><br><span class="line">  <span class="keyword">var</span> lineCap = [<span class="string">"butt"</span>, <span class="string">"round"</span>, <span class="string">"square"</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建路径</span></span><br><span class="line">  ctx.strokeStyle = <span class="string">"#09f"</span>;</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">140</span>, <span class="number">10</span>);</span><br><span class="line">  ctx.moveTo(<span class="number">10</span>, <span class="number">140</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">140</span>, <span class="number">140</span>);</span><br><span class="line">  ctx.stroke();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 画线条</span></span><br><span class="line">  ctx.strokeStyle = <span class="string">"black"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lineCap.length; i++) &#123;</span><br><span class="line">    ctx.lineWidth = <span class="number">15</span>;</span><br><span class="line">    ctx.lineCap = lineCap[i];</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(<span class="number">25</span> + i * <span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line">    ctx.lineTo(<span class="number">25</span> + i * <span class="number">50</span>, <span class="number">140</span>);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lineJoin-属性的例子"><a href="#lineJoin-属性的例子" class="headerlink" title="lineJoin 属性的例子"></a>lineJoin 属性的例子</h3><p>lineJoin 的属性值决定了图形中两线段连接处所显示的样子。它可以是这三种之一：round, bevel 和 miter。默认是 miter。<br><img src="https://mdn.mozillademos.org/files/237/Canvas_linejoin.png" alt="图示"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>).getContext(<span class="string">"2d"</span>);</span><br><span class="line">  <span class="keyword">var</span> lineJoin = [<span class="string">"round"</span>, <span class="string">"bevel"</span>, <span class="string">"miter"</span>];</span><br><span class="line">  ctx.lineWidth = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lineJoin.length; i++) &#123;</span><br><span class="line">    ctx.lineJoin = lineJoin[i];</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(<span class="number">-5</span>, <span class="number">5</span> + i * <span class="number">40</span>);</span><br><span class="line">    ctx.lineTo(<span class="number">35</span>, <span class="number">45</span> + i * <span class="number">40</span>);</span><br><span class="line">    ctx.lineTo(<span class="number">75</span>, <span class="number">5</span> + i * <span class="number">40</span>);</span><br><span class="line">    ctx.lineTo(<span class="number">115</span>, <span class="number">45</span> + i * <span class="number">40</span>);</span><br><span class="line">    ctx.lineTo(<span class="number">155</span>, <span class="number">5</span> + i * <span class="number">40</span>);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="miterLimit-属性的演示例子"><a href="#miterLimit-属性的演示例子" class="headerlink" title="miterLimit 属性的演示例子"></a>miterLimit 属性的演示例子</h3><p>miterLimit 属性就是用来设定外延交点与连接点的最大距离，如果交点距离大于此值，连接效果会变成了 bevel。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>).getContext(<span class="string">"2d"</span>);</span><br><span class="line">  ctx.lineWidth = <span class="number">10</span>;</span><br><span class="line">  ctx.miterLimit =<span class="number">1</span>;</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(<span class="number">-5</span>, <span class="number">45</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">35</span>, <span class="number">85</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">75</span>, <span class="number">45</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">115</span>, <span class="number">85</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">155</span>, <span class="number">45</span>;</span><br><span class="line">  ctx.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渐变-Gradients"><a href="#渐变-Gradients" class="headerlink" title="渐变 Gradients"></a>渐变 Gradients</h2><p><code>createLinearGradient(x1, y1, x2, y2)</code><br>createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。<br><code>createRadialGradient(x1, y1, r1, x2, y2, r2)</code><br>createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。</p><h3 id="createLinearGradient-的例子"><a href="#createLinearGradient-的例子" class="headerlink" title="createLinearGradient 的例子"></a>createLinearGradient 的例子</h3><p><img src="https://mdn.mozillademos.org/files/235/Canvas_lineargradient.png" alt="图示"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>).getContext(<span class="string">"2d"</span>);</span><br><span class="line">  <span class="comment">// Create gradients</span></span><br><span class="line">  <span class="keyword">var</span> lingrad = ctx.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>);</span><br><span class="line">  lingrad.addColorStop(<span class="number">0</span>, <span class="string">"#00ABEB"</span>);</span><br><span class="line">  lingrad.addColorStop(<span class="number">0.5</span>, <span class="string">"#fff"</span>);</span><br><span class="line">  lingrad.addColorStop(<span class="number">0.5</span>, <span class="string">"#26C000"</span>);</span><br><span class="line">  lingrad.addColorStop(<span class="number">1</span>, <span class="string">"#fff"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> lingrad2 = ctx.createLinearGradient(<span class="number">0</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">95</span>);</span><br><span class="line">  lingrad2.addColorStop(<span class="number">0.5</span>, <span class="string">"#000"</span>);</span><br><span class="line">  lingrad2.addColorStop(<span class="number">1</span>, <span class="string">"rgba(0,0,0,0)"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// assign gradients to fill and stroke styles</span></span><br><span class="line">  ctx.fillStyle = lingrad;</span><br><span class="line">  ctx.strokeStyle = lingrad2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// draw shapes</span></span><br><span class="line">  ctx.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">130</span>, <span class="number">130</span>);</span><br><span class="line">  ctx.strokeRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createRadialGradient-的例"><a href="#createRadialGradient-的例" class="headerlink" title="createRadialGradient 的例"></a>createRadialGradient 的例</h3><p><img src="https://mdn.mozillademos.org/files/244/Canvas_radialgradient.png" alt="图示"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>).getContext(<span class="string">"2d"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建渐变</span></span><br><span class="line">  <span class="keyword">var</span> radgrad = ctx.createRadialGradient(<span class="number">45</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">52</span>, <span class="number">50</span>, <span class="number">30</span>);</span><br><span class="line">  radgrad.addColorStop(<span class="number">0</span>, <span class="string">"#A7D30C"</span>);</span><br><span class="line">  radgrad.addColorStop(<span class="number">0.9</span>, <span class="string">"#019F62"</span>);</span><br><span class="line">  radgrad.addColorStop(<span class="number">1</span>, <span class="string">"rgba(1,159,98,0)"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> radgrad2 = ctx.createRadialGradient(<span class="number">105</span>, <span class="number">105</span>, <span class="number">20</span>, <span class="number">112</span>, <span class="number">120</span>, <span class="number">50</span>);</span><br><span class="line">  radgrad2.addColorStop(<span class="number">0</span>, <span class="string">"#FF5F98"</span>);</span><br><span class="line">  radgrad2.addColorStop(<span class="number">0.75</span>, <span class="string">"#FF0188"</span>);</span><br><span class="line">  radgrad2.addColorStop(<span class="number">1</span>, <span class="string">"rgba(255,1,136,0)"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> radgrad3 = ctx.createRadialGradient(<span class="number">95</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">102</span>, <span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line">  radgrad3.addColorStop(<span class="number">0</span>, <span class="string">"#00C9FF"</span>);</span><br><span class="line">  radgrad3.addColorStop(<span class="number">0.8</span>, <span class="string">"#00B5E2"</span>);</span><br><span class="line">  radgrad3.addColorStop(<span class="number">1</span>, <span class="string">"rgba(0,201,255,0)"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> radgrad4 = ctx.createRadialGradient(<span class="number">0</span>, <span class="number">150</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">140</span>, <span class="number">90</span>);</span><br><span class="line">  radgrad4.addColorStop(<span class="number">0</span>, <span class="string">"#F4F201"</span>);</span><br><span class="line">  radgrad4.addColorStop(<span class="number">0.8</span>, <span class="string">"#E4C700"</span>);</span><br><span class="line">  radgrad4.addColorStop(<span class="number">1</span>, <span class="string">"rgba(228,199,0,0)"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 画图形</span></span><br><span class="line">  ctx.fillStyle = radgrad4;</span><br><span class="line">  ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">  ctx.fillStyle = radgrad3;</span><br><span class="line">  ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">  ctx.fillStyle = radgrad2;</span><br><span class="line">  ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">  ctx.fillStyle = radgrad;</span><br><span class="line">  ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>内容来源 <a href="https://developer.mozilla.org/" target="_blank" rel="noopener">https://developer.mozilla.org/</a></p></blockquote><p>好记性不如烂笔头,跟着文档一顿敲</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;色彩-Colors&quot;&gt;&lt;a href=&quot;#色彩-Colors&quot; class=&quot;headerlink&quot; title=&quot;色彩 Colors&quot;&gt;&lt;/a&gt;色彩 Colors&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="WebGL" scheme="https://chenwenkai8023ni.github.io/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>git命令</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/341ecd43.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/341ecd43.html</id>
    <published>2020-07-10T04:30:31.000Z</published>
    <updated>2020-07-25T03:01:06.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h2><a id="more"></a><p><strong>Git 常用命令速查</strong></p><p>git branch 查看本地所有分支<br>git status 查看当前状态<br>git commit 提交<br>git branch -a 查看所有的分支<br>git branch -r 查看远程所有分支<br>git commit -am “init” 提交并且加注释<br>git remote add origin <a href="mailto:git@192.168.1.119">git@192.168.1.119</a>:ndshow<br>git push origin master 将文件给推到服务器上<br>git remote show origin 显示远程库 origin 里的资源<br>git push origin master:develop<br>git push origin master:hb-dev 将本地库与服务器上的库进行关联<br>git checkout –track origin/dev 切换到远程 dev 分支<br>git branch -D master develop 删除本地库 develop<br>git checkout -b dev 建立一个新的本地分支 dev<br>git merge origin/dev 将分支 dev 与当前分支进行合并<br>git checkout dev 切换到本地 dev 分支<br>git remote show 查看远程库<br>git add .<br>git rm 文件名(包括路径) 从 git 中删除指定文件<br>git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来<br>git config –list 看所有用户<br>git ls-files 看已经被提交的<br>git rm [file name] 删除一个文件<br>git commit -a 提交当前 repos 的所有的改变<br>git add [file name] 添加一个文件到 git index<br>git commit -v 当你用－v 参数的时候可以看 commit 的差异<br>git commit -m “This is the message describing the commit” 添加 commit 信息<br>git commit -a -a 是代表 add，把所有的 change 加到 git index 里然后再 commit<br>git commit -a -v 一般提交命令<br>git log 看你 commit 的日志<br>git diff 查看尚未暂存的更新<br>git rm a.a 移除文件(从暂存区和工作区中删除)<br>git rm –cached a.a 移除文件(只从暂存区中删除)<br>git commit -m “remove” 移除文件(从 Git 中删除)<br>git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)<br>git diff –cached 或 $ git diff –staged 查看尚未提交的更新<br>git stash push 将文件给 push 到一个临时空间中<br>git stash pop 将文件从临时空间 pop 下来<br>-——————————————————–<br>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:username/Hello-World.git<br>git push origin master 将本地项目给提交到服务器中<br>-———————————————————-<br>git pull 本地与服务器端同步<br>-—————————————————————-<br>git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。<br>git push origin serverfix:awesomebranch<br>-—————————————————————–<br>git fetch 相当于是从远程获取最新版本到本地，不会自动 merge<br>git commit -a -m “log_message” (-a 是提交所有改动，-m 是加入 log 信息) 本地修改同步至服务器端 ：<br>git branch branch_0.1 master 从主分支 master 创建 branch_0.1 分支<br>git branch -m branch_0.1 branch_1.0 将 branch_0.1 重命名为 branch_1.0<br>git checkout branch_1.0/master 切换到 branch_1.0/master 分支<br>du -hs</p><p>git branch 删除远程 branch<br>git push origin :branch_remote_name<br>git branch -r -d branch_remote_name<br>-———————————————————-</p><p>初始化版本库，并提交到远程服务器端<br>mkdir WebApp<br>cd WebApp<br>git init 本地初始化<br>touch README<br>git add README 添加文件<br>git commit -m ‘first commit’<br>git remote add origin <a href="mailto:git@github.com">git@github.com</a>:daixu/WebApp.git</p><p>增加一个远程服务器端</p><p>上面的命令会增加 URL 地址为‘git@github.com:daixu/WebApp.git’，名称为 origin 的远程服务器库，以后提交代码的时候只需要使用 origin 别名即可</p><h2 id="1、常用的-Git-命令"><a href="#1、常用的-Git-命令" class="headerlink" title="1、常用的 Git 命令"></a>1、常用的 Git 命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>简要说明</strong></th></tr></thead><tbody><tr><td>git add</td><td>添加至暂存区</td></tr><tr><td>git add–interactive</td><td>交互式添加</td></tr><tr><td>git apply</td><td>应用补丁</td></tr><tr><td>git am</td><td>应用邮件格式补丁</td></tr><tr><td>git annotate</td><td>同义词，等同于 git blame</td></tr><tr><td>git archive</td><td>文件归档打包</td></tr><tr><td>git bisect</td><td>二分查找</td></tr><tr><td>git blame</td><td>文件逐行追溯</td></tr><tr><td>git branch</td><td>分支管理</td></tr><tr><td>git cat-file</td><td>版本库对象研究工具</td></tr><tr><td>git checkout</td><td>检出到工作区、切换或创建分支</td></tr><tr><td>git cherry-pick</td><td>提交拣选</td></tr><tr><td>git citool</td><td>图形化提交，相当于 git gui 命令</td></tr><tr><td>git clean</td><td>清除工作区未跟踪文件</td></tr><tr><td>git clone</td><td>克隆版本库</td></tr><tr><td>git commit</td><td>提交</td></tr><tr><td>git config</td><td>查询和修改配置</td></tr><tr><td>git describe</td><td>通过里程碑直观地显示提交 ID</td></tr><tr><td>git diff</td><td>差异比较</td></tr><tr><td>git difftool</td><td>调用图形化差异比较工具</td></tr><tr><td>git fetch</td><td>获取远程版本库的提交</td></tr><tr><td>git format-patch</td><td>创建邮件格式的补丁文件。参见 git am 命令</td></tr><tr><td>git grep</td><td>文件内容搜索定位工具</td></tr><tr><td>git gui</td><td>基于 Tcl/Tk 的图形化工具，侧重提交等操作</td></tr><tr><td>git help</td><td>帮助</td></tr><tr><td>git init</td><td>版本库初始化</td></tr><tr><td>git init-db*</td><td>同义词，等同于 git init</td></tr><tr><td>git log</td><td>显示提交日志</td></tr><tr><td>git merge</td><td>分支合并</td></tr><tr><td>git mergetool</td><td>图形化冲突解决</td></tr><tr><td>git mv</td><td>重命名</td></tr><tr><td>git pull</td><td>拉回远程版本库的提交</td></tr><tr><td>git push</td><td>推送至远程版本库</td></tr><tr><td>git rebase</td><td>分支变基</td></tr><tr><td>git rebase–interactive</td><td>交互式分支变基</td></tr><tr><td>git reflog</td><td>分支等引用变更记录管理</td></tr><tr><td>git remote</td><td>远程版本库管理</td></tr><tr><td>git repo-config*</td><td>同义词，等同于 git config</td></tr><tr><td>git reset</td><td>重置改变分支“游标”指向</td></tr><tr><td>git rev-parse</td><td>将各种引用表示法转换为哈希值等</td></tr><tr><td>git revert</td><td>反转提交</td></tr><tr><td>git rm</td><td>删除文件</td></tr><tr><td>git show</td><td>显示各种类型的对象</td></tr><tr><td>git stage*</td><td>同义词，等同于 git add</td></tr><tr><td>git stash</td><td>保存和恢复进度</td></tr><tr><td>git status</td><td>显示工作区文件状态</td></tr><tr><td>git tag</td><td>里程碑管理</td></tr></tbody></table><h2 id="2、对象库操作相关命令"><a href="#2、对象库操作相关命令" class="headerlink" title="2、对象库操作相关命令"></a>2、对象库操作相关命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>简要说明</strong></th></tr></thead><tbody><tr><td>git commit-tree</td><td>从树对象创建提交</td></tr><tr><td>git hash-object</td><td>从标准输入或文件计算哈希值或创建对象</td></tr><tr><td>git ls-files</td><td>显示工作区和暂存区文件</td></tr><tr><td>git ls-tree</td><td>显示树对象包含的文件</td></tr><tr><td>git mktag</td><td>读取标准输入创建一个里程碑对象</td></tr><tr><td>git mktree</td><td>读取标准输入创建一个树对象</td></tr><tr><td>git read-tree</td><td>读取树对象到暂存区</td></tr><tr><td>git update-index</td><td>工作区内容注册到暂存区及暂存区管理</td></tr><tr><td>git unpack-file</td><td>创建临时文件包含指定 blob 的内容</td></tr><tr><td>git write-tree</td><td>从暂存区创建一个树对象</td></tr></tbody></table><h2 id="3、引用操作相关命令"><a href="#3、引用操作相关命令" class="headerlink" title="3、引用操作相关命令"></a>3、引用操作相关命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>简要说明</strong></th></tr></thead><tbody><tr><td>git check-ref-format</td><td>检查引用名称是否符合规范</td></tr><tr><td>git for-each-ref</td><td>引用迭代器，用于 shell 编程</td></tr><tr><td>git ls-remote</td><td>显示远程版本库的引用</td></tr><tr><td>git name-rev</td><td>将提交 ID 显示为友好名称</td></tr><tr><td>git peek-remote*</td><td>过时命令，请使用 git ls-remote</td></tr><tr><td>git rev-list</td><td>显示版本范围</td></tr><tr><td>git show-branch</td><td>显示分支列表及拓扑关系</td></tr><tr><td>git show-ref</td><td>显示本地引用</td></tr><tr><td>git symbolic-ref</td><td>显示或者设置符号引用</td></tr><tr><td>git update-ref</td><td>更新引用的指向</td></tr><tr><td>git verify-tag</td><td>校验 GPG 签名的 Tag</td></tr></tbody></table><h2 id="4、版本库管理相关命令"><a href="#4、版本库管理相关命令" class="headerlink" title="4、版本库管理相关命令"></a>4、版本库管理相关命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>简要说明</strong></th></tr></thead><tbody><tr><td>git count-objects</td><td>显示松散对象的数量和磁盘占用</td></tr><tr><td>git filter-branch</td><td>版本库重构</td></tr><tr><td>git fsck</td><td>对象库完整性检查</td></tr><tr><td>git fsck-objects*</td><td>同义词，等同于 git fsck</td></tr><tr><td>git gc</td><td>版本库存储优化</td></tr><tr><td>git index-pack</td><td>从打包文件创建对应的索引文件</td></tr><tr><td>git lost-found*</td><td>过时，请使用 git fsck –lost-found 命令</td></tr><tr><td>git pack-objects</td><td>从标准输入读入对象 ID，打包到文件</td></tr><tr><td>git pack-redundant</td><td>查找多余的 pack 文件</td></tr><tr><td>git pack-refs</td><td>将引用打包到 .git/packed-refs 文件中</td></tr><tr><td>git prune</td><td>从对象库删除过期对象</td></tr><tr><td>git prune-packed</td><td>将已经打包的松散对象删除</td></tr><tr><td>git relink</td><td>为本地版本库中相同的对象建立硬连接</td></tr><tr><td>git repack</td><td>将版本库未打包的松散对象打包</td></tr><tr><td>git show-index</td><td>读取包的索引文件，显示打包文件中的内容</td></tr><tr><td>git unpack-objects</td><td>从打包文件释放文件</td></tr><tr><td>git verify-pack</td><td>校验对象库打包文件</td></tr></tbody></table><h2 id="5、数据传输相关命令"><a href="#5、数据传输相关命令" class="headerlink" title="5、数据传输相关命令"></a>5、数据传输相关命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>简要说明</strong></th></tr></thead><tbody><tr><td>git fetch-pack</td><td>执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象</td></tr><tr><td>git receive-pack</td><td>执行 git push 命令时在远程执行的命令，用于接受推送的数据</td></tr><tr><td>git send-pack</td><td>执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据</td></tr><tr><td>git upload-archive</td><td>执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档</td></tr><tr><td>git upload-pack</td><td>执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传</td></tr></tbody></table><h2 id="6、邮件相关命令"><a href="#6、邮件相关命令" class="headerlink" title="6、邮件相关命令"></a>6、邮件相关命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>简要说明</strong></th></tr></thead><tbody><tr><td>git imap-send</td><td>将补丁通过 IMAP 发送</td></tr><tr><td>git mailinfo</td><td>从邮件导出提交说明和补丁</td></tr><tr><td>git mailsplit</td><td>将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件</td></tr><tr><td>git request-pull</td><td>创建包含提交间差异和执行 PULL 操作地址的信息</td></tr><tr><td>git send-email</td><td>发送邮件</td></tr></tbody></table><h2 id="7、协议相关命令"><a href="#7、协议相关命令" class="headerlink" title="7、协议相关命令"></a>7、协议相关命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>简要说明</strong></th></tr></thead><tbody><tr><td>git daemon</td><td>实现 Git 协议</td></tr><tr><td>git http-backend</td><td>实现 HTTP 协议的 CGI 程序，支持智能 HTTP 协议</td></tr><tr><td>git instaweb</td><td>即时启动浏览器通过 gitweb 浏览当前版本库</td></tr><tr><td>git shell</td><td>受限制的 shell，提供仅执行 Git 命令的 SSH 访问</td></tr><tr><td>git update-server-info</td><td>更新哑协议需要的辅助文件</td></tr><tr><td>git http-fetch</td><td>通过 HTTP 协议获取版本库</td></tr><tr><td>git http-push</td><td>通过 HTTP/DAV 协议推送</td></tr><tr><td>git remote-ext</td><td>由 Git 命令调用，通过外部命令提供扩展协议支持</td></tr><tr><td>git remote-fd</td><td>由 Git 命令调用，使用文件描述符作为协议接口</td></tr><tr><td>git remote-ftp</td><td>由 Git 命令调用，提供对 FTP 协议的支持</td></tr><tr><td>git remote-ftps</td><td>由 Git 命令调用，提供对 FTPS 协议的支持</td></tr><tr><td>git remote-http</td><td>由 Git 命令调用，提供对 HTTP 协议的支持</td></tr><tr><td>git remote-https</td><td>由 Git 命令调用，提供对 HTTPS 协议的支持</td></tr><tr><td>git remote-testgit</td><td>协议扩展示例脚本</td></tr></tbody></table><h2 id="8、版本库转换和交互相关命令"><a href="#8、版本库转换和交互相关命令" class="headerlink" title="8、版本库转换和交互相关命令"></a>8、版本库转换和交互相关命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>简要说明</strong></th></tr></thead><tbody><tr><td>git archimport</td><td>导入 Arch 版本库到 Git</td></tr><tr><td>git bundle</td><td>提交打包和解包，以便在不同版本库间传递</td></tr><tr><td>git cvsexportcommit</td><td>将 Git 的一个提交作为一个 CVS 检出</td></tr><tr><td>git cvsimport</td><td>导入 CVS 版本库到 Git。或者使用 cvs2git</td></tr><tr><td>git cvsserver</td><td>Git 的 CVS 协议模拟器，可供 CVS 命令访问 Git 版本库</td></tr><tr><td>git fast-export</td><td>将提交导出为 git-fast-import 格式</td></tr><tr><td>git fast-import</td><td>其他版本库迁移至 Git 的通用工具</td></tr><tr><td>git svn</td><td>Git 作为前端操作 Subversion</td></tr></tbody></table><h2 id="9、合并相关的辅助命令"><a href="#9、合并相关的辅助命令" class="headerlink" title="9、合并相关的辅助命令"></a>9、合并相关的辅助命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>简要说明</strong></th></tr></thead><tbody><tr><td>git merge-base</td><td>供其他脚本调用，找到两个或多个提交最近的共同祖先</td></tr><tr><td>git merge-file</td><td>针对文件的两个不同版本执行三向文件合并</td></tr><tr><td>git merge-index</td><td>对 index 中的冲突文件调用指定的冲突解决工具</td></tr><tr><td>git merge-octopus</td><td>合并两个以上分支。参见 git merge 的 octopus 合并策略</td></tr><tr><td>git merge-one-file</td><td>由 git merge-index 调用的标准辅助程序</td></tr><tr><td>git merge-ours</td><td>合并使用本地版本，抛弃他人版本。参见 git merge 的 ours 合并策略</td></tr><tr><td>git merge-recursive</td><td>针对两个分支的三向合并。参见 git merge 的 recursive 合并策略</td></tr><tr><td>git merge-resolve</td><td>针对两个分支的三向合并。参见 git merge 的 resolve 合并策略</td></tr><tr><td>git merge-subtree</td><td>子树合并。参见 git merge 的 subtree 合并策略</td></tr><tr><td>git merge-tree</td><td>显式三向合并结果，不改变暂存区</td></tr><tr><td>git fmt-merge-msg</td><td>供执行合并操作的脚本调用，用于创建一个合并提交说明</td></tr><tr><td>git rerere</td><td>重用所记录的冲突解决方案</td></tr></tbody></table><h2 id="10、-杂项"><a href="#10、-杂项" class="headerlink" title="10、 杂项"></a>10、 杂项</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>简要说明</strong></th></tr></thead><tbody><tr><td>git bisect–helper</td><td>由 git bisect 命令调用，确认二分查找进度</td></tr><tr><td>git check-attr</td><td>显示某个文件是否设置了某个属性</td></tr><tr><td>git checkout-index</td><td>从暂存区拷贝文件至工作区</td></tr><tr><td>git cherry</td><td>查找没有合并到上游的提交</td></tr><tr><td>git diff-files</td><td>比较暂存区和工作区，相当于 git diff –raw</td></tr><tr><td>git diff-index</td><td>比较暂存区和版本库，相当于 git diff –cached –raw</td></tr><tr><td>git diff-tree</td><td>比较两个树对象，相当于 git diff –raw A B</td></tr><tr><td>git difftool–helper</td><td>由 git difftool 命令调用，默认要使用的差异比较工具</td></tr><tr><td>git get-tar-commit-id</td><td>从 git archive 创建的 tar 包中提取提交 ID</td></tr><tr><td>git gui–askpass</td><td>命令 git gui 的获取用户口令输入界面</td></tr><tr><td>git notes</td><td>提交评论管理</td></tr><tr><td>git patch-id</td><td>补丁过滤行号和空白字符后生成补丁唯一 ID</td></tr><tr><td>git quiltimport</td><td>将 Quilt 补丁列表应用到当前分支</td></tr><tr><td>git replace</td><td>提交替换</td></tr><tr><td>git shortlog</td><td>对 git log 的汇总输出，适合于产品发布说明</td></tr><tr><td>git stripspace</td><td>删除空行，供其他脚本调用</td></tr><tr><td>git submodule</td><td>子模组管理</td></tr><tr><td>git tar-tree</td><td>过时命令，请使用 git archive</td></tr><tr><td>git var</td><td>显示 Git 环境变量</td></tr><tr><td>git web–browse</td><td>启动浏览器以查看目录或文件</td></tr><tr><td>git whatchanged</td><td>显示提交历史及每次提交的改动</td></tr><tr><td>git-mergetool–lib</td><td>包含于其他脚本中，提供合并/差异比较工具的选择和执行</td></tr><tr><td>git-parse-remote</td><td>包含于其他脚本中，提供操作远程版本库的函数</td></tr><tr><td>git-sh-setup</td><td>包含于其他脚本中，提供 shell 编程的函数库</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;git-命令&quot;&gt;&lt;a href=&quot;#git-命令&quot; class=&quot;headerlink&quot; title=&quot;git 命令&quot;&gt;&lt;/a&gt;git 命令&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="git" scheme="https://chenwenkai8023ni.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Three.js</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/715c0509.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/715c0509.html</id>
    <published>2020-07-10T04:14:31.000Z</published>
    <updated>2020-07-25T03:01:28.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Three-js"><a href="#Three-js" class="headerlink" title="Three.js"></a>Three.js</h2><a id="more"></a><h3 id="三大组建"><a href="#三大组建" class="headerlink" title="三大组建"></a>三大组建</h3><p>在 Three.js 中要渲染物体到网页中,需要三个组建:场景(scene),相机(camera)和渲染器(renderer).必须有着三个东西,才能将物体渲染到网页中</p><p>创建这三要素的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scene = <span class="keyword">new</span> THREE.Scene(); <span class="comment">//场景</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">); <span class="comment">// 透视相机</span></span><br><span class="line"><span class="keyword">var</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer(); <span class="comment">//渲染器</span></span><br><span class="line"><span class="comment">// 设置渲染器的大小为窗口的内宽度，也就是内容区的宽度</span></span><br><span class="line">renderer.serSize(<span class="built_in">window</span>.innerWidth, <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(renderer.domElement);</span><br></pre></td></tr></table></figure><p>在 Threejs 中场景只有一种,用 var scene = new THREE.Scene(); 构建</p><h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><p>相机决定了场景中那个角度的景色会显示出来,相机就像人的眼睛一样，人站在不同位置，抬头或者低头都能够看到不同的景色。</p><p>场景只有一种，但是相机却又很多种。和现实中一样，不同的相机确定了呈相的各个方面。比如有的相机适合人像，有的相机适合风景，专业的摄影师根据实际用途不一样，选择不同的相机。对程序员来说，只要设置不同的相机参数，就能够让相机产生不一样的效果。</p><p>在 Threejs 中有多种相机，这里介绍两种，它们是：<br>透视相机（THREE.PerspectiveCamera）、这里我们使用一个透视相机，透视相机的参数很多，这里先不详细讲解。后面关于相机的那一章，我们会花大力气来讲。定义一个相机的代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> THREE.PerspectiveCamera(</span><br><span class="line">  <span class="number">75</span>,</span><br><span class="line">  <span class="built_in">window</span>.innerWidth / <span class="built_in">window</span>.innerHeight,</span><br><span class="line">  <span class="number">0.1</span>,</span><br><span class="line">  <span class="number">1000</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Three-js&quot;&gt;&lt;a href=&quot;#Three-js&quot; class=&quot;headerlink&quot; title=&quot;Three.js&quot;&gt;&lt;/a&gt;Three.js&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="WebGL" scheme="https://chenwenkai8023ni.github.io/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>Babylon基本使用</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/54207.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/54207.html</id>
    <published>2020-07-09T02:07:00.000Z</published>
    <updated>2020-07-25T03:00:50.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Babylon-js-一个-WebGL-开源框架"><a href="#Babylon-js-一个-WebGL-开源框架" class="headerlink" title="Babylon.js 一个 WebGL 开源框架"></a>Babylon.js 一个 WebGL 开源框架</h2><a id="more"></a><h3 id="Babylonjs-中的基本元素使用"><a href="#Babylonjs-中的基本元素使用" class="headerlink" title="Babylonjs 中的基本元素使用"></a>Babylonjs 中的基本元素使用</h3><blockquote><p><code>使用 babylonjs 创建盒子</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = BABYLON.MeshBuilder.CreateBox(<span class="string">"box"</span>, &#123;&#125;, scene); <span class="comment">//默认盒子;</span></span><br><span class="line"><span class="keyword">var</span> mybox = BABYON.MeshBuilder.CreateBox(</span><br><span class="line">  <span class="string">"mybox"</span>,</span><br><span class="line">  &#123; <span class="attr">height</span>: <span class="number">5</span>, <span class="attr">width</span>: <span class="number">2</span>, <span class="attr">depth</span>: <span class="number">0.5</span> &#125;,</span><br><span class="line">  scene</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>参数 1: 盒子名称</li><li>参数 2: 盒子的基本属性</li><li>参数 3: 它将放到场景的变量</li></ul><p>盒子第二个基本属性参数可以是下面的值：</p><table><thead><tr><th>选型</th><th>值</th><th>默认值</th></tr></thead><tbody><tr><td>size</td><td>盒子边长大小</td><td>1</td></tr><tr><td>height</td><td>盒子的高度</td><td>size</td></tr><tr><td>width</td><td>盒子的宽度</td><td>size</td></tr><tr><td>depth</td><td>盒子的深度</td><td>size</td></tr><tr><td>faceColors</td><td>盒子 6 个面的颜色,是一个 6 个元素的 Color4 数组</td><td>每个面默认白色 Color4(1, 1, 1, 1)</td></tr><tr><td>faceUV</td><td>盒子 6 个面的法向量</td><td>默认法向量 UVs(0, 0, 1, 1)</td></tr><tr><td>updatable</td><td>是否可以更新</td><td>false 就是不可以改变其属性</td></tr><tr><td>sideOrientation</td><td>(number) 盒子绘里面，还是外面</td><td>DEFAULTSIDE(缺省面)</td></tr></tbody></table><blockquote><p><code>使用 babylonjs 创建一个球体</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sphere = BABYLON.MeshBuilder.CreateSphere(<span class="string">"sphere"</span>, &#123;&#125;, scene); <span class="comment">//默认球体</span></span><br><span class="line"><span class="keyword">var</span> mySphere = BABYLON.MeshBuilder.CreateSphere(</span><br><span class="line">  <span class="string">"mySphere"</span>,</span><br><span class="line">  &#123; <span class="attr">diameter</span>: <span class="number">2</span>, <span class="attr">diameterX</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  scene</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>参数一：球体的名字</p></li><li><p>参数二：球体的基本属性</p></li><li><p>参数三：它将放到的那个场景的变量</p><p>参数二是一个元组，可取值如下：</p></li></ul><table><thead><tr><th>选型</th><th>值</th><th>默认值</th></tr></thead><tbody><tr><td>segments</td><td>细分段数</td><td>32</td></tr><tr><td>diameter</td><td>圆的半径</td><td>1</td></tr><tr><td>diameterX</td><td>x 轴径大小, 如果写了会重写 diameter 参数</td><td>diameter</td></tr><tr><td>diameterY</td><td>y 轴径大小, 如果写了会重写 diameter 参数</td><td>diameter</td></tr><tr><td>diameterZ</td><td>z 轴径大小, 如果写了会重写 diameter 参数</td><td>diameter</td></tr><tr><td>arc</td><td>这是一个比较难的参数，建议你想放弃理解</td><td>1</td></tr><tr><td>slice</td><td>这是一个比较难的参数，建议你想放弃理解</td><td>1</td></tr><tr><td>updatable</td><td>这个网格是否改变属性</td><td>false</td></tr><tr><td>sideOrientation</td><td>(number) 盒子绘里面，还是外面</td><td>DEFAULTSIDE</td></tr></tbody></table><blockquote><p><code>使用 babylonjs 创建一个平面</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plane = BABYLON.MeshBuilder.CreatePlane(<span class="string">"plane"</span>, &#123;&#125;, scene); <span class="comment">// default plane</span></span><br><span class="line"><span class="keyword">var</span> myPlane = BABYLON.MeshBuilder.CreatePlane(</span><br><span class="line">  <span class="string">"myPlane"</span>,</span><br><span class="line">  &#123; <span class="attr">width</span>: <span class="number">5</span>, <span class="attr">height</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  scene</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>参数一：平面的名字</li><li>参数二：平面的基本属性</li><li>参数三：它将放到的那个场景的变量</li></ul><table><thead><tr><th>选型</th><th>值</th><th>默认值</th></tr></thead><tbody><tr><td>size</td><td>平面的长宽高</td><td>1</td></tr><tr><td>width</td><td>单独设置平面的长</td><td>size</td></tr><tr><td>height</td><td>单独设置平面的宽</td><td>size</td></tr><tr><td>updatable</td><td>这个网格是否可以更新</td><td>false</td></tr><tr><td>sideOrientation</td><td>盒子绘里面，还是外面</td><td>DEFAULTSIDE</td></tr><tr><td>frontUVs</td><td>正面的法向量数组</td><td>Vector4(0,0, 1,1)</td></tr><tr><td>backUVs</td><td>(Vector4[]) 背面的法向量数组</td><td>Vector4(0,0, 1,1)</td></tr><tr><td>sourcePlane</td><td>(Plane) source plane (maths) the mesh will be transformed to</td><td>null</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Babylon-js-一个-WebGL-开源框架&quot;&gt;&lt;a href=&quot;#Babylon-js-一个-WebGL-开源框架&quot; class=&quot;headerlink&quot; title=&quot;Babylon.js 一个 WebGL 开源框架&quot;&gt;&lt;/a&gt;Babylon.js 一个 WebGL 开源框架&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="WebGL" scheme="https://chenwenkai8023ni.github.io/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>mvvm与mvc</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/44428.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/44428.html</id>
    <published>2020-07-09T01:21:53.000Z</published>
    <updated>2020-07-25T03:01:25.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mvvm-与-mvc"><a href="#mvvm-与-mvc" class="headerlink" title="mvvm 与 mvc"></a>mvvm 与 mvc</h2><a id="more"></a><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><blockquote><p>Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分.通常模型对象负责在数据库中存取数据。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">比如我们人类有一双手，一双眼睛，一个脑袋，没有尾巴，这就是模型，Model定义了这个模块的数据模型。</span><br><span class="line">在代码中体现为数据管理者，Model负责对数据进行获取及存放。</span><br><span class="line">数据不可能凭空生成的，要么是从服务器上面获取到的数据，要么是本地数据库中的数据，</span><br><span class="line">也有可能是用户在UI上填写的表单即将上传到服务器上面存放，所以需要有数据来源。</span><br><span class="line">既然Model是数据管理者，则自然由它来负责获取数据。</span><br><span class="line">Controller不需要关心Model是如何拿到数据的，只管调用就行了。</span><br><span class="line">数据存放的地方是在Model，而使用数据的地方是在Controller，</span><br><span class="line">所以Model应该提供接口供controller访问其存放的数据（通常通过.h里面的只读属性）</span><br></pre></td></tr></table></figure><blockquote><p>View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">View，视图，简单来说，就是我们在界面上看见的一切。</span><br><span class="line">它们有一部分是我们UI定死的，也就是不会根据数据来更新显示的，</span><br><span class="line">比如一些Logo图片啊，这里有个按钮啊，那里有个输入框啊，一些显示特定内容的label啊等等；</span><br><span class="line">有一部分是会根据数据来显示内容的，比如tableView来显示好友列表啊，</span><br><span class="line">这个tableView的显示内容肯定是根据数据来显示的。</span><br><span class="line">我们使用MVC解决问题的时候，通常是解决这些根据数据来显示内容的视图。</span><br></pre></td></tr></table></figure><blockquote><p>Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Controller是MVC中的数据和视图的协调者，也就是在Controller里面把Model的数据赋值给View来显示</span><br><span class="line">（或者是View接收用户输入的数据然后由Controller把这些数据传给Model来保存到本地或者上传到</span><br><span class="line">服务器）。</span><br></pre></td></tr></table></figure><blockquote><p>各部分之间的通信方式如下。 所有通信都是单向的。</p></blockquote><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png" alt="图示"></p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><blockquote><p>MVVM 模式将 Controller 改名为 ViewModel.</p></blockquote><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015020110.png" alt="图示"></p><p>它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;mvvm-与-mvc&quot;&gt;&lt;a href=&quot;#mvvm-与-mvc&quot; class=&quot;headerlink&quot; title=&quot;mvvm 与 mvc&quot;&gt;&lt;/a&gt;mvvm 与 mvc&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="web" scheme="https://chenwenkai8023ni.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>js防抖节流</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/15954.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/15954.html</id>
    <published>2020-07-08T01:37:42.000Z</published>
    <updated>2020-07-25T03:01:10.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js-防抖节流"><a href="#js-防抖节流" class="headerlink" title="js 防抖节流"></a>js 防抖节流</h2><a id="more"></a><p><strong>防抖和节流目前是前端开发中最重要的 2 个函数</strong></p><h4 id="防抖使用场景"><a href="#防抖使用场景" class="headerlink" title="防抖使用场景"></a>防抖使用场景</h4><blockquote><p>在输入框中输入自己搜索的内容</p></blockquote><p><img src="https://s1.ax1x.com/2020/07/08/UEwruR.png" alt="图示"></p><ul><li>当输入男时,为了更好的体验,通常会出现对应的联想内容,发送一次网络请求</li><li>继续输入男士时,再一次发送请求,出现对应内容</li><li>在输入完男士夏季套装一共需要发送 6 次请求</li></ul><p>但是事实上不根本不需要怎么多次请求</p><ul><li>正确的做法应该是在合适的情况发送请求</li><li>例如用户快速输入男士夏季套装,那么就发送一次请求</li><li>例如用户每输入一个字停顿一会,这时就发送 6 次请求<br><img src="https://s1.ax1x.com/2020/07/08/UEDu4K.md.png" alt="图示"></li></ul><h4 id="节流使用场景"><a href="#节流使用场景" class="headerlink" title="节流使用场景"></a>节流使用场景</h4><blockquote><p>监听页面滚动事件<br>鼠标移动事件<br>按钮点击事件</p></blockquote><ul><li>在某个时间内,某个函数只能被触发执行一次</li></ul><p><img src="https://s1.ax1x.com/2020/07/08/UEgSE9.jpg" alt="图示"></p><h4 id="简单防抖函数实现"><a href="#简单防抖函数实现" class="headerlink" title="简单防抖函数实现"></a>简单防抖函数实现</h4><p><strong>基本功能</strong></p><ul><li>当触发一个函数,不会立即执行这个函数,而是延迟(使用定时器)</li><li>如果延迟内有重新触发函数,那么取消上一个函数执行(取消定时器)</li><li>如果在延迟时间内,没有重新触发函数,函数正常执行</li></ul><blockquote><p>代码实现</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优化参数和 this</p></blockquote><p>通常 input 事件触发都会带有参数传递,而且触发函数的 this 指向当前元素节点<br>上方代码的 fn 函数是个普通的函数,this 指向 window,且没有携带参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) clearTimeout(timer);</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">arguments</span>;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(that, arg);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单节流函数实现"><a href="#简单节流函数实现" class="headerlink" title="简单节流函数实现"></a>简单节流函数实现</h4><p><strong>基本功能</strong></p><p>使用时间戳方式来实现</p><ul><li>使用一个 last 记录上一次执行时间</li><li>每次执行前获取当前时间</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">if</span> (now - last &gt; interval) &#123;</span><br><span class="line">      fn.apply(that, arg);</span><br><span class="line">      last = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;js-防抖节流&quot;&gt;&lt;a href=&quot;#js-防抖节流&quot; class=&quot;headerlink&quot; title=&quot;js 防抖节流&quot;&gt;&lt;/a&gt;js 防抖节流&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="JS" scheme="https://chenwenkai8023ni.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>js原型与原型链,闭包</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/64299.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/64299.html</id>
    <published>2020-07-07T05:47:59.000Z</published>
    <updated>2020-07-25T01:16:11.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js-闭包"><a href="#js-闭包" class="headerlink" title="js 闭包"></a>js 闭包</h2><a id="more"></a><p><strong>变量的作用域</strong><br>要理解闭包，首先必须理解 Javascript 特殊的变量作用域。</p><p>变量的作用域无非就是两种：全局变量和局部变量。</p><p>Javascript 特殊之处，就在于函数内部可以直接读取全局变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(n);</span><br><span class="line">&#125;</span><br><span class="line">f1(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><p>在函数外部自然无法读取函数内的局部变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line">alert(n); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>函数内部声明变量的时候，一定要使用 var/let/const 命令。如果不用的话，你实际上声明了一个全局变量！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line">alert(n); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><p><strong>从外部读取局部变量</strong><br>在函数的内部，再定义一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><p><strong>闭包的概念</strong><br>上述事例代码 f2 就是闭包.我的理解是,闭包就是能够读取其他函数内部变量的函数。<br>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”.闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p><strong>闭包的用途</strong><br>一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  nAdd = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    n += <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br><span class="line">nAdd();</span><br><span class="line">result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>在这段代码中,result 就是闭包 f2 函数它一共运行了两次，第一次的值是 999，第二次的值是<br>1000。这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除。</p><p>为什么会这样呢？因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量。其次，nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。</p><p><strong>使用闭包的注意点</strong></p><ol><li><p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，</p></li><li><p>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value）</p></li></ol><p><strong>思考题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">"My Object"</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//普通函数this指向window</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//The Window</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">  name: <span class="string">"My Object"</span>,</span><br><span class="line">  getNameFunc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 对象函数中this指向对象本身</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//My Object</span></span><br></pre></td></tr></table></figure><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p><strong>prototype</strong><br>每个函数都要一个 prototype 属性<br>每个 JavaScript 对象(null 除外)在创建的时候就会关联另一个对象.这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"李四"</span>;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1); <span class="comment">//李四</span></span><br><span class="line"><span class="built_in">console</span>.log(person2); <span class="comment">//李四</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1490251-48851bf37a08259d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/556/format/webp" alt="图示"></p><p><strong>proto</strong><br>每一个 JavaScript 对象(null 除外)都具有一个属性,叫 proto,这个属性会指向该对象原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1490251-e7476a8697e97aab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567/format/webp" alt="图示"></p><p><strong>constructor</strong><br>每一个原型都有一个 constructor 属性指向关联的构造函数 实例原型指向构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1490251-0cac772635e8a128.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518/format/webp" alt="图示"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>**实例与原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"Kevin"</span>;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">"Daisy"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Daisy</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p><p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.proto ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 Kevin。</p><p><strong>原型与原型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">"Kevin"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1490251-293b8fe01cf2ef5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/609/format/webp" alt="图示"></p><p><strong>原型链</strong><br>最终指向 null<code>console.log(Object.prototype.__proto__ === null) // true</code><br><img src="https://upload-images.jianshu.io/upload_images/1490251-3089c135df71c956.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/604/format/webp" alt="图示"><br><strong>总结</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person.__proto__ = Person.prototype;</span><br><span class="line">Person.__proto__ === <span class="built_in">Function</span>.prototype;</span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype;</span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>;</span><br><span class="line">Person.prototype.__proto__ == <span class="built_in">Object</span>.prototype;</span><br><span class="line">Obejct.prototype.__proto__ === <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;js-闭包&quot;&gt;&lt;a href=&quot;#js-闭包&quot; class=&quot;headerlink&quot; title=&quot;js 闭包&quot;&gt;&lt;/a&gt;js 闭包&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="JS" scheme="https://chenwenkai8023ni.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>牛客网js错题总结</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/51388.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/51388.html</id>
    <published>2020-07-07T03:03:15.000Z</published>
    <updated>2020-07-25T03:00:25.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js-错题集"><a href="#js-错题集" class="headerlink" title="js 错题集"></a>js 错题集</h2><a id="more"></a><h3 id="2020-年-7-月"><a href="#2020-年-7-月" class="headerlink" title="2020 年 7 月"></a>2020 年 7 月</h3><blockquote><p><strong>1 在 javascript 中，下列不属于数组方法的是()</strong></p></blockquote><ol><li>concat()<ul><li>用于连接 2 个或多个数组不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</li></ul></li><li>sort()<ul><li>用于对数组的元素进行排序。排序顺序可以是字母或数字，并按升序或降序。</li></ul></li><li>reverse()<ul><li>用于颠倒数组中元素的顺序。</li></ul></li><li>length()<ul><li>length 为数组属性,没有 length()方法</li></ul></li></ol><blockquote><p><strong>2 白屏时间 first paint 和可交互时间 dom ready 的关系是？</strong></p></blockquote><ol><li>先触发 first paint ，后触发 dom ready</li><li>先触发 dom ready，后触发 first paint</li><li>一起触发</li><li>没关系</li></ol><ul><li>白屏时间（first Paint Time）——用户从打开页面开始到页面开始有东西呈现为止</li><li>首屏时间——用户浏览器首屏内所有内容都呈现出来所花费的时间</li><li>用户可操作时间(dom Interactive)——用户可以进行正常的点击、输入等操作，默认可以统计 domready 时间，因为通常会在这时候绑定事件操作</li><li>总下载时间——页面所有资源都加载完成并呈现出来所花的时间，即页面 onload 的时间</li></ul><blockquote><p><strong>3 页面有一个按钮 button id 为 button1，通过原生的 js 如何禁用？（）</strong></p></blockquote><ol><li>document.getElementById(“button1”).setAttribute(“Readolny”,true);<ul><li>readonly 是把输入字段设置为只读，注意是输入字段，如 text textarea 等</li></ul></li><li>document.getElementById(“button1”).setAttribute(“disabled”,”true”);<ul><li>disabled 是禁用 input 元素</li></ul></li><li>document.getElementById(“button1”).Readolny=true;</li><li>document.getElementById(“button1”).disabled=true;</li></ol><blockquote><p><strong>4 关于 JavaScript 里的 xml 处理，以下说法正确的是 ()</strong></p></blockquote><ol><li>Xml 是种可扩展标记语言，格式更规范，是作为未来 html 的替代</li><li>Xml 一般用于传输和存储数据，是对 html 的补充，两者的目的不同</li><li>在 JavaScript 里解析和处理 xml 数据时，因为浏览器的不同，其做法也不同</li><li>在 IE 浏览器里处理 xml，首先需要创建 ActiveXObject 对象</li></ol><p><strong>什么是 XML?</strong></p><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）</li><li>XML 是一种标记语言，很类似 HTML</li><li>XML 是一种标记语言，很类似 HTML</li><li>XML 标签没有被预定义。您需要自行定义标签。</li><li>XML 被设计为具有自我描述性。</li><li>XML 是 W3C 的推荐标准</li></ul><p><strong>XML 与 HTML 的主要差异</strong></p><ul><li>XML 不是 HTML 的替代。</li><li>XML 和 HTML 为不同的目的而设计：</li><li>XML 被设计为传输和存储数据，其焦点是数据的内容。</li><li>HTML 被设计用来显示数据，其焦点是数据的外观。</li><li>HTML 旨在显示信息，而 XML 旨在传输信息。</li></ul><blockquote><p><strong>5 如何获取下面表单 select 域的选择部分的文本？()</strong><form name="a"><select name="a" size="1" id=”obj”><option value="a">1</option><option value="b">2</option><option value="c">3</option></select></form></p></blockquote><ol><li>obj.options[obj.selectedIndex].text<ul><li>console 输出的是 1,</li></ul></li><li>obj.options[obj.selectedIndex].value<ul><li>console 输出的是 a,</li></ul></li><li>obj. value</li><li>obj.text</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//首先获得下拉框的节点对象；</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">"obj"</span>);</span><br><span class="line">  <span class="comment">//1.如何获得当前选中的值？：</span></span><br><span class="line">  <span class="keyword">var</span> value = obj.value;</span><br><span class="line">  <span class="comment">//2.如何获得该下拉框所有的option的节点对象</span></span><br><span class="line">  <span class="keyword">var</span> options = obj.options;</span><br><span class="line">  <span class="comment">//注意：得到的options是一个对象数组</span></span><br><span class="line">  <span class="comment">//3.如何获得第几个option的value值?比如我要获取第一option的value,可以这样：</span></span><br><span class="line">  <span class="keyword">var</span> value1 = options[<span class="number">0</span>].value;</span><br><span class="line">  <span class="comment">//4.如何获得第几个option的文本内容?比如我要获取第一option的文本,可以这样：</span></span><br><span class="line">  <span class="keyword">var</span> text1 = options[<span class="number">0</span>].text;</span><br><span class="line">  <span class="comment">//5.如何获得当前选中的option的索引？</span></span><br><span class="line">  <span class="keyword">var</span> index = obj.selectedIndex;</span><br><span class="line">  <span class="comment">//6.如何获得当前选中的option的文本内容？</span></span><br><span class="line">  <span class="comment">//从第2个问题，我们已经获得所有的option的对象数组options了</span></span><br><span class="line">  <span class="comment">//又从第5个问题，我们获取到了当前选中的option的索引值</span></span><br><span class="line">  <span class="comment">//所以我们只要同options[index]下标的方法得到当前选中的option了</span></span><br><span class="line">  <span class="keyword">var</span> selectedText = options[index].text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>6 解释型语言的特性有什么？</strong></p></blockquote><ol><li>非独立</li><li>效率低</li><li>独立</li><li>效率高性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">解释性语言和编译性语言的定义：</span><br><span class="line">计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。</span><br><span class="line">翻译的方式有两种，一个是编译，一个是解释。两种方式只是翻译的时间不同。</span><br><span class="line"></span><br><span class="line">解释性语言的定义：</span><br><span class="line">解释性语言的程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。</span><br><span class="line">现代解释性语言通常把源程序编译成中间代码，然后用解释器把中间代码一条条翻译成目标机器代码，一条条执行。</span><br><span class="line"></span><br><span class="line">编译性语言的定义：</span><br><span class="line">编译性语言写的程序在被执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。</span><br></pre></td></tr></table></figure><blockquote><p><strong>7 只能输入零和非零开头的数字，正确的正则表达式是（）</strong></p></blockquote><ol><li>^(0|[1-9][0-9]\\*)$</li><li>^(0|[1-9][1-9]\\*)$</li><li>^(0|[1-9][0-9])$</li><li>^\+[1-9][0-9]\\*$</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">只能输入零／非零开头的数字</span><br><span class="line">^ 以。。。开头，$以。。。结尾。</span><br><span class="line">*任意多次</span><br><span class="line">|或的意思</span><br><span class="line">（）组</span><br><span class="line">[]集合</span><br></pre></td></tr></table></figure><blockquote><p><strong>8 以下哪些方法会返回一个数组？</strong></p></blockquote><ol><li>Object.keys()</li><li>String.prototype.split()</li><li>Array.prototype.join()</li><li>Promise.all()</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A.Object.keys()</span><br><span class="line">返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。</span><br><span class="line">split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。</span><br><span class="line">join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</span><br><span class="line">Promise.all(iterable) 方法返回一个 Promise 实例，</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;js-错题集&quot;&gt;&lt;a href=&quot;#js-错题集&quot; class=&quot;headerlink&quot; title=&quot;js 错题集&quot;&gt;&lt;/a&gt;js 错题集&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="JS" scheme="https://chenwenkai8023ni.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器重排与重绘</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/41644.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/41644.html</id>
    <published>2020-07-07T01:38:43.000Z</published>
    <updated>2020-07-25T02:59:59.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器重绘和重排"><a href="#浏览器重绘和重排" class="headerlink" title="浏览器重绘和重排"></a>浏览器重绘和重排</h2><a id="more"></a><h3 id="网页生成过程"><a href="#网页生成过程" class="headerlink" title="网页生成过程"></a>网页生成过程</h3><ol><li>html 被 html 解析器解析成 DOM 树</li><li>css 被 css 解析器解析成 CSSOM 树</li><li>结合 DOM 树与 CSSOM 树,生成一个渲染树</li><li>生成布局,即将所有渲染树的所有节点进行平面合成</li><li>将布局绘制在屏幕上</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/16/167b642d014afaf1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图示"></p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>网页在生成的时候,至少会渲染一次,在用户访问的过程中，还会不断重新渲染.<br>重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)。</p><h4 id="重排比重绘影响大"><a href="#重排比重绘影响大" class="headerlink" title="重排比重绘影响大"></a>重排比重绘影响大</h4><ul><li>重绘：某些元素的外观被改变，例如：元素的填充颜色</li><li>重排：重新生成布局，重新排列元素。</li></ul><p><strong>只改变元素外观,不会引起网页重排,但当浏览器重排之后,将会重新绘制重排影响的部分</strong><br><strong>“重绘”不一定会出现”重排”，”重排”必然会出现”重绘”</strong></p><h3 id="重排-reflow"><a href="#重排-reflow" class="headerlink" title="重排(reflow)"></a>重排(reflow)</h3><p><strong>概念</strong><br>当 DOM 的变化影响了元素的几何信息(DOM 对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。<br><strong>常见引起重排属性和方法</strong><br>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排</p><ol><li>添加或者删除可见的 DOM 元素</li><li>元素尺寸改变——边距、填充、边框、宽度和高度</li><li>内容变化，比如用户在 input 框中输入文字</li><li>浏览器窗口尺寸改变——resize 事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值</li></ol><table><thead><tr><th>常见引起重排属性和方法</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>width</td><td>height</td><td>margin</td><td>padding</td></tr><tr><td>display</td><td>border</td><td>position</td><td>overflow</td></tr><tr><td>clientWidth</td><td>clientHeight</td><td>clientTop</td><td>clientLeft</td></tr><tr><td>offsetWidth</td><td>offsetHeight</td><td>offsetTop</td><td>offsetLeft</td></tr><tr><td>scrollWidth</td><td>scrollHeight</td><td>scrollTop</td><td>scrollLeft</td></tr><tr><td>scrollIntoView()</td><td>scrollTo()</td><td>getComputedStyle()</td><td>—</td></tr><tr><td>getBoundingClientRect()</td><td>scrollIntoViewIfNeeded()</td><td>—</td><td>—</td></tr></tbody></table><h4 id="重排影响的范围"><a href="#重排影响的范围" class="headerlink" title="重排影响的范围"></a>重排影响的范围</h4><p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围 DOM 重新排列，影响的范围有两种：</p><ul><li>全局范围：从根节点 html 开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>全局范围重排：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>BDing<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>male<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>coding<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>loving<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当p节点上发生r重排时，hello和body也会重新渲染，甚至h5和ol都会收到影响。 --&gt;</span></span><br></pre></td></tr></table></figure><p><strong>局部范围重排</strong><br>把一个 dom 的宽高之类的几何信息定死，然后在 dom 内部触发重排，就只会重新渲染该 dom 内部的元素，而不会影响到外界。</p><h4 id="尽可能的减少重排的次数、重排范围"><a href="#尽可能的减少重排的次数、重排范围" class="headerlink" title="尽可能的减少重排的次数、重排范围"></a>尽可能的减少重排的次数、重排范围</h4><ul><li>重排需要更新渲染树,性能花销非常大:</li><li>它们的代价是高昂的，会破坏用户体验，并且让 UI 展示非常迟缓</li><li>重排的性能花销跟渲染树有多少节点需要重新构建有关系：</li><li>尽量以局部布局的形式组织 html 结构，尽可能小的影响重排的范围。</li></ul><h3 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘(repaint)"></a>重绘(repaint)</h3><p><strong>概念</strong><br>当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。<br><strong>常见的引起重绘的属性:</strong></p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>color</td><td>border-style</td><td>visibility</td><td>background</td></tr><tr><td>text-decoration</td><td>background-image</td><td>background-position</td><td>background-repeat</td></tr><tr><td>outline-color</td><td>outline</td><td>outline-style</td><td>border-radius</td></tr><tr><td>outline-width</td><td>box-shadow</td><td>background-size</td><td></td></tr></tbody></table><h4 id="浏览器的渲染队列"><a href="#浏览器的渲染队列" class="headerlink" title="浏览器的渲染队列"></a>浏览器的渲染队列</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = <span class="string">"10px"</span>;</span><br><span class="line">div.style.top = <span class="string">"10px"</span>;</span><br><span class="line">div.style.width = <span class="string">"20px"</span>;</span><br><span class="line">div.style.height = <span class="string">"20px"</span>;</span><br></pre></td></tr></table></figure><p>这段代码理论上会触发 4 次重排+重绘，因为每一次都改变了元素的几何属性，实际上最后只触发了一次重排，这都得益于浏览器的渲染队列机制：<br>当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p><h4 id="强制刷新队列"><a href="#强制刷新队列" class="headerlink" title="强制刷新队列"></a>强制刷新队列</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = <span class="string">"10px"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetLeft);</span><br><span class="line">div.style.top = <span class="string">"10px"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetTop);</span><br><span class="line">div.style.width = <span class="string">"20px"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetWidth);</span><br><span class="line">div.style.height = <span class="string">"20px"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetHeight);</span><br></pre></td></tr></table></figure><p>这段代码会触发 4 次重排+重绘，因为在<code>console</code>中你请求的这几个样式信息，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。</p><p><strong>因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。</strong><br><strong>强制刷新队列的 style 样式请求</strong></p><ol><li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li><li>scrollTop, scrollLeft, scrollWidth, scrollHeight</li><li>clientTop, clientLeft, clientWidth, clientHeight</li><li>getComputedStyle(), 或者 IE 的 currentStyle</li></ol><p><strong>在开发中,应该谨慎的使用这些 style 请求,注意上下文关系,避免一行代码一个重排,这对性能是个巨大的消耗</strong></p><h3 id="重排优化建议"><a href="#重排优化建议" class="headerlink" title="重排优化建议"></a>重排优化建议</h3><h4 id="1-分离读写操作"><a href="#1-分离读写操作" class="headerlink" title="1. 分离读写操作"></a>1. 分离读写操作</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = <span class="string">"10px"</span>;</span><br><span class="line">div.style.top = <span class="string">"10px"</span>;</span><br><span class="line">div.style.width = <span class="string">"20px"</span>;</span><br><span class="line">div.style.height = <span class="string">"20px"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetLeft);</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetTop);</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetWidth);</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetHeight);</span><br></pre></td></tr></table></figure><p>还是上面触发 4 次重排+重绘的代码，这次只触发了一次重排：<br>在第一个<code>console</code>的时候，浏览器把之前上面四个写操作的渲染队列都给清空了。剩下的 console，因为渲染队列本来就是空的，所以并没有触发重排，仅仅拿值而已。</p><h4 id="2-样式集中改变"><a href="#2-样式集中改变" class="headerlink" title="2. 样式集中改变"></a>2. 样式集中改变</h4><p>建议通过改变 class 或者 csstext 属性集中改变样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</span><br><span class="line">el.style.left = left + <span class="string">"px"</span>;</span><br><span class="line">el.style.top = top + <span class="string">"px"</span>;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.className += <span class="string">" theclassname"</span>;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.style.cssText += <span class="string">"; left: "</span> + left + <span class="string">"px; top: "</span> + top + <span class="string">"px;"</span>;</span><br></pre></td></tr></table></figure><h4 id="3-缓存布局信息"><a href="#3-缓存布局信息" class="headerlink" title="3. 缓存布局信息"></a>3. 缓存布局信息</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad 强制刷新 触发两次重排</span></span><br><span class="line">div.style.left = div.offsetLeft + <span class="number">1</span> + <span class="string">"px"</span>;</span><br><span class="line">div.style.top = div.offsetTop + <span class="number">1</span> + <span class="string">"px"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.offsetLeft;</span><br><span class="line"><span class="keyword">var</span> curTop = div.offsetTop;</span><br><span class="line">div.style.left = curLeft + <span class="number">1</span> + <span class="string">"px"</span>;</span><br><span class="line">div.style.top = curTop + <span class="number">1</span> + <span class="string">"px"</span>;</span><br></pre></td></tr></table></figure><h4 id="4-离线改变-dom"><a href="#4-离线改变-dom" class="headerlink" title="4. 离线改变 dom"></a>4. 离线改变 dom</h4><p>在要<code>多次</code>操作 dom 之前，通过 display 隐藏 dom，当操作完成之后，才将元素的 display 属性为可见，因为不可见的元素不会触发重排和重绘。这样就只会触发 2 次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dom.display = <span class="string">"none"</span>;</span><br><span class="line"><span class="comment">// 修改 dom 样式</span></span><br><span class="line">dom.display = <span class="string">"block"</span>;</span><br></pre></td></tr></table></figure><p>通过使用 DocumentFragment 创建一个 dom 碎片,在它上面批量操作 dom，操作完成之后，再添加到文档中，这样只会触发一次重排。</p><h4 id="5-position-属性为-absolute-或-fixed"><a href="#5-position-属性为-absolute-或-fixed" class="headerlink" title="5. position 属性为 absolute 或 fixed"></a>5. position 属性为 absolute 或 fixed</h4><p>position 属性为 absolute 或 fixed 的元素，重排开销比较小，不用考虑它对其他元素的影响</p><h4 id="6-优化动画"><a href="#6-优化动画" class="headerlink" title="6. 优化动画"></a>6. 优化动画</h4><ul><li><p>可以把动画效果应用到 position 属性为 absolute 或 fixed 的元素上，这样对其他元素影响较小</p></li><li><p>启用 GPPU 加速</p><p><strong>GPU(图像加速器)</strong></p></li></ul><p>GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。<br>GPU 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3 转换（transitions），CSS3 3D 变换（transforms），WebGL 和视频(video)。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据上面的结论</span></span><br><span class="line"><span class="comment"> * 将 2d transform 换成 3d</span></span><br><span class="line"><span class="comment"> * 就可以强制开启 GPU 加速</span></span><br><span class="line"><span class="comment"> * 提高动画性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">10px</span>, <span class="number">10px</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>重排也是导致 DOM 脚本执行效率低的关键因素之一，重排与重绘作为大厂经常出现的面试题，并且涉及的性能优化，这是前端必须掌握的基本概念/技能之一(敲黑板!)。<br>重排会不断触发这是不可避免的，但我们在开发时，应尽量按照文中的建议来组织代码，这种优化，需要平时有意识的去做，一点一滴的去做，希望大家重视一下。</p><blockquote><p>作者：OBKoro1 来源：掘金<br>链接：<a href="https://juejin.im/post/5c15f797f265da61141c7f86" target="_blank" rel="noopener">https://juejin.im/post/5c15f797f265da61141c7f86</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浏览器重绘和重排&quot;&gt;&lt;a href=&quot;#浏览器重绘和重排&quot; class=&quot;headerlink&quot; title=&quot;浏览器重绘和重排&quot;&gt;&lt;/a&gt;浏览器重绘和重排&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="web" scheme="https://chenwenkai8023ni.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>canvas_基础方法</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/58774.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/58774.html</id>
    <published>2020-07-05T02:28:47.000Z</published>
    <updated>2020-07-25T03:00:54.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><a id="more"></a><p>canvas 标签只有 2 个属性,宽度和高度,在没设置宽度高度时,初始化宽度为 300 和 150 像素,<br>该元素可以使用 CSS 来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果 CSS 的尺寸与初始画布的比例不一致，它会出现扭曲.<br>canvas 元素默认是空白的,为了使用 canvas 需要找到渲染上下文,然后进行绘制它有一个 <code>getcontext()</code> 方法.通过这个方法获得渲染上下文进行绘画</p><h2 id="使用-canvas-来绘制图形"><a href="#使用-canvas-来绘制图形" class="headerlink" title="使用 canvas 来绘制图形"></a>使用 canvas 来绘制图形</h2><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p><img src="https://mdn.mozillademos.org/files/224/Canvas_default_grid.png" alt=" 图示"><br><code>fillRect(x,y,width,height)</code><br>绘制一个填充的矩形<br><code>strokeRect(x,y,width,height)</code><br>绘制一个矩形边框<br><code>clearRect(x,y,width,height)</code><br>清除指定矩形区域，让清除部分完全透明。<br><strong>矩形例子</strong></p><p><img src="https://mdn.mozillademos.org/files/245/Canvas_rect.png" alt="图示"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">if</span> (canvas.getContext) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">  ctx.fillRect(<span class="number">25</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//位于坐标x,y出生成宽高100的填充矩形</span></span><br><span class="line">  ctx.clearRect(<span class="number">45</span>, <span class="number">45</span>, <span class="number">60</span>, <span class="number">60</span>); <span class="comment">//位于坐标x,y45出生成宽高60的透明区域</span></span><br><span class="line">  ctx.strokeRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>); <span class="comment">//位于坐标x,y50出生成宽高50的边框区域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上的三个函数绘制之后会马上显现在canvas上，即时生效。</span></span><br></pre></td></tr></table></figure><h3 id="绘制路线"><a href="#绘制路线" class="headerlink" title="绘制路线"></a>绘制路线</h3><p>图形的基本元素是路径,路径通过不同颜色和宽度的线段或曲线连接形成不同的形状的集合<br>一个路径，甚至一个子路径，都是闭合的。使用路径绘制图形需要一些额外的步骤。</p><ol><li>创建路径起始点</li><li>使用画图命令去画出路径。</li><li>路径封闭</li><li>通过描边或填充路径区域来渲染图形。</li></ol><p><code>beginPath()</code> 新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。<br><code>closePath()</code>闭合路径之后图形绘制命令又重新指向到上下文中。<br><code>stroke()</code>以线条形式绘制<br><code>fill()</code>填充路径绘制</p><blockquote><p>当前路径为空，即调用 beginPath()之后，或者 canvas 刚建的时候，第一条路径构造命令通常被视为是 moveTo（），无论实际上是什么。出于这个原因，你几乎总是要在设置路径之后专门指定你的起始位置。<br>闭合路径 closePath(),不是必需的。这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做。<br>当你调用 fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用 closePath()函数。但是调用 stroke()时不会自动闭合。</p></blockquote><p><code>moveTo(x,y)</code>将笔触移动到指定的坐标 x 以及 y 上。(定义路径起点)<br>当 canvas 初始化或者 beginPath()调用后，你通常会使用 moveTo()函数设置起点。我们也能够使用 moveTo()绘制一些不连续的路径。看一下下面的笑脸例子。我将用到 moveTo()方法（红线处）的地方标记了。<br><code>lineTo(x, y)</code>绘制一条从当前位置到指定 x 以及 y 位置的直线。<br>该方法有两个参数：x 以及 y ，代表坐标系中直线结束的点。开始点和之前的绘制路径有关，之前路径的结束点就是接下来的开始点，开始点也可以通过 moveTo()函数改变。<br><code>arc(x,y,radius,startAngle,endAngle,anticlockwise)</code>画一个以（x,y）为圆心的以 radius 为半径的圆弧（圆），从 startAngle 开始到 endAngle 结束，按照 anticlockwise 给定的方向（默认为顺时针）来生成。<br><code>arcTo(x1, y1, x2, y2, radius)</code>据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。</p><blockquote><p>arc 方法，该方法有六个参数：x,y 为绘制圆弧所在圆上的圆心坐标。radius 为半径。startAngle 以及 endAngle 参数用弧度定义了开始以及结束的弧度。这些都是以 x 轴为基准。参数 anticlockwise 为一个布尔值。为 true 时，是逆时针方向，否则顺时针方向。<br>arc()函数中表示角的单位是弧度，不是角度。角度与弧度的 js 表达式:弧度=(Math.PI/180)*角度。</p></blockquote><p><img src="https://mdn.mozillademos.org/files/238/Canvas_lineTo.png" alt="图示"> <img src="https://mdn.mozillademos.org/files/252/Canvas_smiley.png" alt="图示"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">if</span> (canvas.getContext) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">  <span class="comment">// 填充三角形</span></span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(<span class="number">25</span>, <span class="number">25</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">105</span>, <span class="number">25</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">25</span>, <span class="number">105</span>);</span><br><span class="line">  ctx.fill(); <span class="comment">//生成填充图形</span></span><br><span class="line">  <span class="comment">// 描边三角形</span></span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(<span class="number">125</span>, <span class="number">125</span>); <span class="comment">//定义起点</span></span><br><span class="line">  ctx.lineTo(<span class="number">125</span>, <span class="number">45</span>);</span><br><span class="line">  ctx.lineTo(<span class="number">45</span>, <span class="number">125</span>);</span><br><span class="line">  ctx.closePath(); <span class="comment">//以直线形式回到起点</span></span><br><span class="line">  ctx.stroke(); <span class="comment">//生成图形轮廓。</span></span><br><span class="line">  <span class="comment">//绘制笑脸</span></span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.arc(<span class="number">75</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>); <span class="comment">// 绘制</span></span><br><span class="line">  ctx.moveTo(<span class="number">110</span>, <span class="number">75</span>);</span><br><span class="line">  ctx.arc(<span class="number">75</span>, <span class="number">75</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI, <span class="literal">false</span>); <span class="comment">// 口(顺时针)</span></span><br><span class="line">  ctx.moveTo(<span class="number">65</span>, <span class="number">65</span>);</span><br><span class="line">  ctx.arc(<span class="number">60</span>, <span class="number">65</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>); <span class="comment">// 左眼</span></span><br><span class="line">  ctx.moveTo(<span class="number">95</span>, <span class="number">65</span>);</span><br><span class="line">  ctx.arc(<span class="number">90</span>, <span class="number">65</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>); <span class="comment">// 右眼</span></span><br><span class="line">  ctx.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贝塞尔曲线绘制"><a href="#贝塞尔曲线绘制" class="headerlink" title="贝塞尔曲线绘制"></a>贝塞尔曲线绘制</h3><p>贝塞尔曲线一般用来绘制复杂有规律的图形。<br><code>quadraticCurveTo(cp1x, cp1y, x, y)</code><br>绘制二次贝塞尔曲线，cp1x,cp1y 为一个控制点，x,y 为结束点。<br><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code><br>绘制三次贝塞尔曲线，cp1x,cp1y 为控制点一，cp2x,cp2y 为控制点二，x,y 为结束点。<br><img src="https://mdn.mozillademos.org/files/223/Canvas_curves.png" alt="图示"><br>二次贝塞尔曲线有一个开始点（蓝色）、一个结束点（蓝色）以及一个控制点（红色），而三次贝塞尔曲线有两个控制点。<br>参数 x、y 在这两个方法中都是结束点坐标。cp1x,cp1y 为坐标中的第一个控制点，cp2x,cp2y 为坐标中的第二个控制点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">if</span> (canvas.getContext) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 二次贝塞尔曲线对话气泡。</span></span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(<span class="number">75</span>, <span class="number">25</span>);</span><br><span class="line">  ctx.quadraticCurveTo(<span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">62.5</span>);</span><br><span class="line">  ctx.quadraticCurveTo(<span class="number">25</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">  ctx.quadraticCurveTo(<span class="number">50</span>, <span class="number">120</span>, <span class="number">30</span>, <span class="number">125</span>);</span><br><span class="line">  ctx.quadraticCurveTo(<span class="number">60</span>, <span class="number">120</span>, <span class="number">65</span>, <span class="number">100</span>);</span><br><span class="line">  ctx.quadraticCurveTo(<span class="number">125</span>, <span class="number">100</span>, <span class="number">125</span>, <span class="number">62.5</span>);</span><br><span class="line">  ctx.quadraticCurveTo(<span class="number">125</span>, <span class="number">25</span>, <span class="number">75</span>, <span class="number">25</span>);</span><br><span class="line">  ctx.stroke();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//三次贝塞尔曲线 爱心</span></span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.moveTo(<span class="number">75</span>, <span class="number">40</span>);</span><br><span class="line">  ctx.bezierCurveTo(<span class="number">75</span>, <span class="number">37</span>, <span class="number">70</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">25</span>);</span><br><span class="line">  ctx.bezierCurveTo(<span class="number">20</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">62.5</span>, <span class="number">20</span>, <span class="number">62.5</span>);</span><br><span class="line">  ctx.bezierCurveTo(<span class="number">20</span>, <span class="number">80</span>, <span class="number">40</span>, <span class="number">102</span>, <span class="number">75</span>, <span class="number">120</span>);</span><br><span class="line">  ctx.bezierCurveTo(<span class="number">110</span>, <span class="number">102</span>, <span class="number">130</span>, <span class="number">80</span>, <span class="number">130</span>, <span class="number">62.5</span>);</span><br><span class="line">  ctx.bezierCurveTo(<span class="number">130</span>, <span class="number">62.5</span>, <span class="number">130</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">25</span>);</span><br><span class="line">  ctx.bezierCurveTo(<span class="number">85</span>, <span class="number">25</span>, <span class="number">75</span>, <span class="number">37</span>, <span class="number">75</span>, <span class="number">40</span>);</span><br><span class="line">  ctx.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="WebGL" scheme="https://chenwenkai8023ni.github.io/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB笔记</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/48857.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/48857.html</id>
    <published>2020-01-22T07:56:47.000Z</published>
    <updated>2020-07-25T03:01:23.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB基本语法"><a href="#MongoDB基本语法" class="headerlink" title="MongoDB基本语法"></a>MongoDB基本语法</h2> <a id="more"></a><ul><li>创建数据库<ul><li>use databasename(如果数据库不存在，则创建数据库，否则切换到指定的数据库)</li><li>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mydata</span><br><span class="line">switched to db mydata</span><br></pre></td></tr></table></figure></li></ul></li><li>查看所有数据库<ul><li>show dbs</li><li>刚刚创建的数据库不在所有数据库列表中，要显示他，需要向mydata数据库插入一些数据</li><li>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.mydata.insert(&#123;&quot;name&quot;:李四&#125;)</span><br><span class="line">WriteResult(&#123;&quot;nInserted&quot;:1&#125;)</span><br></pre></td></tr></table></figure></li></ul><strong>注意点：在MongoDB中，集合只有在内容插入之后才会创建，创建集合后要插入文档，集合才真正创建</strong></li><li>删除数据库<ul><li>db.dropDatabase() 删除当前数据库默认为test</li><li>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use mydata 切换到要被删除的数据库</span><br><span class="line">switched to db mydata</span><br><span class="line">db.dropDatabase()</span><br><span class="line">&#123;&quot;dropped&quot;:&quot;mydata&quot;,&quot;ok&quot;:1&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>删除集合(表)<ul><li>db.collection.drop()</li><li>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use mydata 创建数据库</span><br><span class="line">db.createCollection(&quot;city&quot;) 创建集合(表)</span><br><span class="line">show tables 展示集合</span><br><span class="line">city</span><br><span class="line">db.city.drop()</span><br><span class="line">true</span><br><span class="line">show tables</span><br></pre></td></tr></table></figure></li></ul></li><li>创建集合<ul><li>db.createCollection(name,options)<ul><li>name:要创建集合名称</li><li>options:可选参数   </li><li>参数如下  </li></ul></li></ul></li></ul><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>capped</td><td>布尔</td><td>可选，如果为true，创建固定集合，固定集合是指由着固定大小的集合当达到最大值时，它会自动覆盖最早的文档。当该值为 true 时，必须指定 size 参数</td></tr><tr><td>autoIndexId</td><td>布尔</td><td>（可选）如为 true，自动在 _id 字段创建索引。默认为 false。</td></tr><tr><td>size</td><td>数值</td><td>（可选）为固定集合指定一个最大值，以千字节计（KB）。如果 capped 为 true，也需要指定该字段。</td></tr><tr><td>max</td><td>数值</td><td>（可选）指定固定集合中包含文档的最大数量。</td></tr></tbody></table><ul><li><p>创建固定集合 mycol，整个集合空间大小 6142800 KB, 文档最大个数为 10000 个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&quot;mycol&quot;, &#123; capped : true, autoIndexId : true, size : </span><br><span class="line">6142800, max : 10000 &#125; )</span><br><span class="line"> &#123; &quot;ok&quot; : 1 &#125;</span><br></pre></td></tr></table></figure></li><li><p>在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.mycol2.insert(&#123;&quot;name&quot; : &quot;菜鸟教程&quot;&#125;)</span><br><span class="line"> show collections</span><br><span class="line"> mycol2</span><br></pre></td></tr></table></figure></li></ul><ul><li>删除集合<ul><li>db.collection.drop()</li><li>返回值</li><li>如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。  </li></ul></li><li>插入文档  <ul><li>使用 insert() 或 save() 方法向集合中插入文档，语法如下：</li><li>db.COLLECTION_NAME.insert(document)</li><li>实例 </li></ul></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.col.insert(&#123;</span><br><span class="line"> title: &#39;MongoDB &#39;, </span><br><span class="line">  content:&#39;一个nosql数据库&#39;,</span><br><span class="line">  text:&#39;文档的数据结构和 JSON 基本一样。&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>我们也可以将数据定义为一个变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document&#x3D;(&#123; </span><br><span class="line">  title: &#39;MongoDB &#39;, </span><br><span class="line">  content:&#39;一个nosql数据库&#39;,</span><br><span class="line">  text:&#39;文档的数据结构和 JSON 基本一样。&#39;</span><br><span class="line">  likes: 100</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>执行插入操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.insert(document)WriteResult(&#123;&quot;nInserted&quot;:1&#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li>db.collection.insertOne():向指定集合中插入一条文档数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> var document &#x3D; db.collection.insertOne(&#123;&quot;a&quot;: 3&#125;)</span><br><span class="line">  document</span><br><span class="line">&#123;</span><br><span class="line">        &quot;acknowledged&quot; : true,</span><br><span class="line">        &quot;insertedId&quot; : ObjectId(&quot;571a218011a82a1d94c02333&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入多条数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; var res &#x3D; db.collection.insertMany([&#123;&quot;b&quot;: 3&#125;, &#123;&#39;c&#39;: 4&#125;])</span><br><span class="line">&gt; res</span><br><span class="line">&#123;</span><br><span class="line">        &quot;acknowledged&quot; : true,</span><br><span class="line">        &quot;insertedIds&quot; : [</span><br><span class="line">                ObjectId(&quot;571a22a911a82a1d94c02337&quot;),</span><br><span class="line">                ObjectId(&quot;571a22a911a82a1d94c02338&quot;)</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>更新文档<ul><li>update()方法用于更新已存在的文档，语法格式如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line"> &lt;query&gt;,</span><br><span class="line"> &lt;update&gt;,</span><br><span class="line"> &#123;</span><br><span class="line">   upsert: &lt;boolean&gt;,</span><br><span class="line">   multi: &lt;boolean&gt;,</span><br><span class="line">   writeConcern: &lt;document&gt;</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>参数说明：<ul><li>query : update的查询条件，类似sql update查询内where后面的。</li><li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li><li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li><li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li><li>writeConcern :可选，抛出异常的级别。</li></ul></li><li>实例 修改col集合title文档<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.update(&#123;&#39;title&#39;:&#39;MongoDB&#39;&#125;,&#123;$set:&#123;&#39;title&#39;:&#39;mongodb&#39;&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li>删除文档<ul><li>remove() 方法的基本语法格式如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line"> &lt;query&gt;,</span><br><span class="line"> &#123;</span><br><span class="line">   justOne: &lt;boolean&gt;,</span><br><span class="line">   writeConcern: &lt;document&gt;</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>参数说明：<ul><li>query :（可选）删除的文档的条件。</li><li>ustOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档</li><li>writeConcern :（可选）抛出异常的级别。</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MongoDB基本语法&quot;&gt;&lt;a href=&quot;#MongoDB基本语法&quot; class=&quot;headerlink&quot; title=&quot;MongoDB基本语法&quot;&gt;&lt;/a&gt;MongoDB基本语法&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="MongoDB" scheme="https://chenwenkai8023ni.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/8235.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/8235.html</id>
    <published>2020-01-18T07:58:02.000Z</published>
    <updated>2020-07-25T03:01:48.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="状态管理与-VueX（跨组件共享数据）"><a href="#状态管理与-VueX（跨组件共享数据）" class="headerlink" title="状态管理与 VueX（跨组件共享数据）"></a>状态管理与 VueX（跨组件共享数据）</h2><a id="more"></a><p>vuex 顾名思义是一款为 vue 而生的状态管理工具。<br>vue 本身自带着 store 模式，其实就是全局注册一个对象，实现数据共享。适合小型数据量少的项目。<br>vuex 适合复杂的单页面应用，涉及到多层次嵌套，多层次组件传值，不同视图对一个状态或者接口的处理。<br><strong>vuex 工作原理</strong><br><img src="https://s1.ax1x.com/2020/07/07/UkkWfs.png" alt="vue工作原理"></p><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><blockquote><p>npm install –save vuex</p></blockquote><h2 id="vuex-的五大核心"><a href="#vuex-的五大核心" class="headerlink" title="vuex 的五大核心"></a>vuex 的五大核心</h2><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>vuex 中的数据源，我们需要保存的数据就保存在这里，可以在页面通过 this.$store.state 来获取我们定义的数据；</p><h3 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h3><p>Getter 相当于 vue 中的 computed 计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被<br>重新计算，这里我们可以通过定义 vuex 的 Getter 来获取，Getters 可以用于监听、state 中的值的变化，返回计算后的结果</p><h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><p>数据我们在页面是获取到了，但是如果我们需要修改值怎么办？如果需要修改 store 中的值唯一的方法就是提交 mutation 来修改</p><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>官方并不介意我们这样直接去修改 store 里面的值，而是让我们去提交一个 actions，在 actions 中提交 mutation 再去修改状态值，</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。<br>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p><h3 id="vuex-辅助函数"><a href="#vuex-辅助函数" class="headerlink" title="vuex 辅助函数"></a>vuex 辅助函数</h3><p>mapState 、mapGetters 、 mapMutations 、mapActions</p><table><thead><tr><th>调用</th><th>方法</th><th>方法</th></tr></thead><tbody><tr><td>state</td><td>this.$store.state</td><td>mapState</td></tr><tr><td>getters</td><td>this.$store.getters</td><td>mapGetters</td></tr><tr><td>mutations</td><td>this.$store.cmmit</td><td>mapMutations</td></tr><tr><td>actions</td><td>this.$store.dispatch</td><td>mapActions</td></tr></tbody></table><p><code>mapState</code>和<code>mapGetter</code>的使用只能在 computed 计算属性中，<br><code>mapMutations</code>和<code>mapActions</code>使用的时候只能在 methods 中调用否则报错</p><h2 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h2><blockquote><p>index.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    num: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    getstateNum(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.num + <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">//根据action commit的type类型匹配进行操作</span></span><br><span class="line">    add(state) &#123;</span><br><span class="line">      state.num = state.num + <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    reducer(state) &#123;</span><br><span class="line">      state.num = state.num - <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="comment">//执行对应操作</span></span><br><span class="line">    addfun(context) &#123;</span><br><span class="line">      <span class="comment">//commit一个type类型</span></span><br><span class="line">      context.commit(<span class="string">"add"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    reducerfun(context) &#123;</span><br><span class="line">      context.commit(<span class="string">"reducer"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>app.vue</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>直接从store获取的num&#123;&#123;this.$store.state.num&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>执行了Getters获得取num&#123;&#123;this.$store.getters.getstateNum&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"reducer"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    add() &#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">//派发action</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.dispatch(<span class="string">"addfun"</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    reducer() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.dispatch(<span class="string">"reducerfun"</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用辅助函数简化代码</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>直接从store获取的num&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>执行了Getters获得取num&#123;&#123;getstateNum&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"reducer"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; mapState  , mapActions , mapGetters  &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  computed:&#123;</span><br><span class="line">    ...mapState(&#123;</span><br><span class="line"><span class="javascript">      num:<span class="function">(<span class="params">state</span>)=&gt;</span>state.num</span></span><br><span class="line">    &#125;)</span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line"><span class="actionscript">      getstateNum:<span class="string">"getstateNum"</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line"><span class="actionscript">        addfun:<span class="string">"addfun"</span>,</span></span><br><span class="line"><span class="actionscript">        reducerfun:<span class="string">"reducerfun"</span></span></span><br><span class="line">    &#125;),</span><br><span class="line">    add()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.addfun()</span></span><br><span class="line">    &#125;,</span><br><span class="line">    reducer() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.reducerfun()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;状态管理与-VueX（跨组件共享数据）&quot;&gt;&lt;a href=&quot;#状态管理与-VueX（跨组件共享数据）&quot; class=&quot;headerlink&quot; title=&quot;状态管理与 VueX（跨组件共享数据）&quot;&gt;&lt;/a&gt;状态管理与 VueX（跨组件共享数据）&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://chenwenkai8023ni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue-router</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/25005.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/25005.html</id>
    <published>2020-01-16T07:58:02.000Z</published>
    <updated>2020-07-25T03:01:30.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-router-基本使用"><a href="#Vue-router-基本使用" class="headerlink" title="Vue-router 基本使用"></a>Vue-router 基本使用</h2><a id="more"></a><h3 id="主要用法"><a href="#主要用法" class="headerlink" title="主要用法"></a>主要用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;安装</span><br><span class="line">npm install --save vue-router</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;引入</span><br><span class="line">main.js</span><br><span class="line">import VueRouter from &#39;vue-router&#39;;</span><br><span class="line">Vue.use(Vuerouter);</span><br><span class="line"></span><br><span class="line">const Routers &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">path:&#39;&#x2F;path&#39;,</span><br><span class="line">    &lt;!-- component: () &#x3D;&gt; import(&#39;@&#x2F;page&#x2F;about&#39;) --&gt;</span><br><span class="line">    &#x2F;&#x2F;异步组件按需加载</span><br><span class="line">    component:(resolve) &#x3D;&gt; require([&#39;.&#x2F;views&#x2F;about.vue&#39;],resolve)</span><br><span class="line"> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">  path:&#39;&#x2F;about&#39;,</span><br><span class="line">    component:(resolve) &#x3D;&gt; require([&#39;.&#x2F;views&#x2F;about.vue&#39;],resolve)</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;index.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;首页&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;about.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;介绍页&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="params-和-query-传参"><a href="#params-和-query-传参" class="headerlink" title="params 和 query 传参"></a>params 和 query 传参</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"course-item"</span> <span class="attr">v-for</span>=<span class="string">"course in courses"</span> <span class="attr">:key</span>=<span class="string">"course.id"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name:'CourseShow',params:&#123;id:course.id&#125;,query:&#123;page:10&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"course.img"</span> <span class="attr">width</span>=<span class="string">"240"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>&#123;&#123;course.name&#125;&#125;<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>价格:&#123;&#123;course.price&#125;&#125;元<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//获取参数 this.$route.params.id this.$route.query.page</span><br></pre></td></tr></table></figure><h3 id="组件跳转"><a href="#组件跳转" class="headerlink" title="组件跳转"></a>组件跳转</h3><blockquote><p>方法 1</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>跳转到<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    replace 不会留下History记录，所以导航不能后退</span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span> <span class="attr">replace</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>方法 2</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>介绍页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleRouter"</span>&gt;</span>跳转到user<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleRouter() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.$router.push(<span class="string">"/user/123"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//第三种</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">//this.$router.replace('/user/123');</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="router-其他方法"><a href="#router-其他方法" class="headerlink" title="$router 其他方法"></a>$router 其他方法</h4><blockquote><p>this.$router.go(-1); 返回上一级</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vue-router-基本使用&quot;&gt;&lt;a href=&quot;#Vue-router-基本使用&quot; class=&quot;headerlink&quot; title=&quot;Vue-router 基本使用&quot;&gt;&lt;/a&gt;Vue-router 基本使用&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://chenwenkai8023ni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vueprop传值</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/46903.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/46903.html</id>
    <published>2020-01-13T07:58:02.000Z</published>
    <updated>2020-07-25T03:01:46.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vueprop-传值基本使用"><a href="#Vueprop-传值基本使用" class="headerlink" title="Vueprop 传值基本使用"></a>Vueprop 传值基本使用</h2><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//传递死数据</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span> <span class="attr">message</span>=<span class="string">"来自父组件的数据"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  Vue.component(<span class="string">"my-component"</span>, &#123;</span></span><br><span class="line"><span class="actionscript">    props: [<span class="string">"message"</span>],</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: "<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;message&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>",</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123; el: <span class="string">"#app"</span> &#125;);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//传递父组件动态数据</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"parentMessage"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span> <span class="attr">:message</span>=<span class="string">"parentMessage"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">"my-component"</span>,&#123;</span></span><br><span class="line"><span class="actionscript">  props:[<span class="string">'message'</span>],</span></span><br><span class="line"><span class="handlebars"><span class="xml">      template:'<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123;message&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>';</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue)(&#123;</span></span><br><span class="line"><span class="actionscript">  el:<span class="string">'#app'</span>,</span></span><br><span class="line">    data:&#123;</span><br><span class="line"><span class="actionscript">    parentMessage:<span class="string">''</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><blockquote><p>父子组件使用自定义事件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>总数：&#123;&#123;total&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">increase</span>=<span class="string">"handleGetTotal"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">reduce</span>=<span class="string">"handleGetTotal"</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  Vue.component(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">template:<span class="string">'&lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;button @click="handleIncrease"&gt;+1&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;button @click="handleReduce"&gt;-1&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;'</span>,</span><br><span class="line">  data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">retrun &#123;</span><br><span class="line">        counter:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;,</span><br><span class="line">   methods:&#123;</span><br><span class="line">   handleIncrease:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.counter++;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'increase'</span>,<span class="keyword">this</span>.counter);</span><br><span class="line">    &#125;,</span><br><span class="line">      handleReduce:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.counter--;</span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'reduce'</span>,<span class="keyword">this</span>.counter);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">  total:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">  handleGetTotal:<span class="function"><span class="keyword">function</span>(<span class="params">total</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.total = total;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">  &lt;component-a&gt;&lt;<span class="regexp">/component-a&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> bus = <span class="keyword">new</span> Vue();</span><br><span class="line">Vue.component(<span class="string">'component-a'</span>,&#123;</span><br><span class="line">template:<span class="string">'&lt;button @click="handleEvent"&gt; 传递事件&lt;/button&gt;'</span>,</span><br><span class="line">  method:&#123;</span><br><span class="line">    handleEvent:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        bus.$emit(<span class="string">'on-message'</span>,<span class="string">'来自组件component-a的内容'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el:<span class="string">'#app'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">  message:<span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    bus.$on(<span class="string">'on-message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    _this.message = msg;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="跨级组件通信"><a href="#跨级组件通信" class="headerlink" title="跨级组件通信"></a>跨级组件通信</h3><blockquote><p>在子组件中，可以使用 this.$parent直接访问该组件的父实例或组件，<br>父组件页可以通过this.$children 访问他所有的子组件，<br>而且可以递归向上或向下无限访问，直到根实例或最内层的组件。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vueprop-传值基本使用&quot;&gt;&lt;a href=&quot;#Vueprop-传值基本使用&quot; class=&quot;headerlink&quot; title=&quot;Vueprop 传值基本使用&quot;&gt;&lt;/a&gt;Vueprop 传值基本使用&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://chenwenkai8023ni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue基本使用</title>
    <link href="https://chenwenkai8023ni.github.io/artcle/51277.html"/>
    <id>https://chenwenkai8023ni.github.io/artcle/51277.html</id>
    <published>2020-01-12T07:58:02.000Z</published>
    <updated>2020-07-25T03:01:39.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-基本使用"><a href="#Vue-基本使用" class="headerlink" title="Vue 基本使用"></a>Vue 基本使用</h2><a id="more"></a><ul><li>指令、表达式</li><li>插值、动态属性</li><li>v-html:会有 xss 风险，会覆盖子组件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>文本插值&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>js表达式&#123;&#123;flag?true:false&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:id</span>=<span class="string">"dynamic"</span>&gt;</span>绑定的动态id&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">"rewhtml"</span>&gt;</span>容易导致 XSS 攻击<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">dynamic</span>]=<span class="string">"doSomething"</span>&gt;</span> 动态事件 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>computed、watch</p></li><li><p>computed 有缓存，data 不变则不会重新计算</p></li><li><p>wacth 默认浅监听</p></li><li><p>watch 监听引用类型需要深度监听，拿不到 oldval</p></li><li><p>class 和 style</p></li><li><p>使用动态属性</p></li><li><p>使用驼峰式写法</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"&#123;&#123;black :isblack&#125;&#125;"</span>&gt;</span>判断是否<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"[black,yellow]"</span>&gt;</span>使用class数组<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">"styleData"</span>&gt;</span>使用style<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">data()&#123; return&#123; isblack:true, black:"black", yellow:"yellow", styleData:&#123;</span><br><span class="line">fontSize:"40px",//转化为驼峰式 color:"red", backgroundColor:"#ccc" &#125; &#125; &#125;</span><br></pre></td></tr></table></figure><ul><li>条件渲染</li><li>v-ifv-else 的用法,可使用变量,也可以使用===表达式</li><li>v-if 和 v-show 的区别</li><li>v-if 和 v-show 的使用场景</li><li>v-if 条件满足就渲染,条件不满足不渲染</li><li>v-show 条件满足就渲染,条件不满足的使用 display:none 但还是渲染</li><li>v-if 有更高的切换开销,v-show 有更高的初始渲染开销。</li><li>如果需要频繁切换,则使用 v-show 较好，如果运行条件不太可能改变,使用 v-if 较好</li></ul><ul><li>循环列表渲染</li><li>key 的重要性，key 不能乱写（random 或 index）</li><li>vo-for 和 v-if 不能一起使用</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  遍历数组</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in listarr"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">    &#123;&#123;item.title&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">遍历对象</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(val,key,index) in listObj"</span> <span class="attr">:key</span>=<span class="string">"key"</span>&gt;</span></span><br><span class="line">    &#123;&#123;val.title&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>事件</li><li>event 参数，自定义参数</li><li>事件修饰符，按键修饰符</li><li>观察事件被绑定到哪里</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;add1&quot;&gt;+1&lt;button&gt;</span><br><span class="line">methods()&#123;</span><br><span class="line">    add1(event)&#123;</span><br><span class="line">        打印出原生的event对象</span><br><span class="line">        console.log(event,event.__proto__.constructor)</span><br><span class="line">        打印出事件在哪个dom元素上监听</span><br><span class="line">        console.log(event.target)</span><br><span class="line">        打印出事件在哪个dom元素触发</span><br><span class="line">        console.log(event.currentTarget)</span><br><span class="line">        &#x2F;&#x2F;event是原生的</span><br><span class="line">        &#x2F;&#x2F;事件被挂载到当前元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>事件修饰符</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>按键修饰符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 只有在 &#96;key&#96; 是 &#96;Enter&#96; 时调用 &#96;vm.submit()&#96; --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">&lt;!-- Alt或Shift被一同按下也会触发--&gt;</span><br><span class="line">&lt;button @click.ctrl&#x3D;&quot;onClick&quot;&gt;a&lt;&#x2F;button&gt;</span><br><span class="line">&lt;!-- 只有Ctrl被按下时触发--&gt;</span><br><span class="line">&lt;button @click.ctrl.exact &#x3D;&quot;onCtrlClick&quot;&gt;a&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><ul><li>表单</li><li>v-model</li><li>表单项 textarea checkbox radio select</li><li>修饰符 lazy number trim</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 截取前后空格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 自动将用户的输入值转为数值类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"number"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;textarea&gt;&#123;&#123;msg&#125;&#125;&lt;/textarea&gt;在vue中是不被允许的 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 单个复选框，绑定到布尔值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多个复选框，绑定到同一个数组： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 单选框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多选时 (绑定到一个数组)：--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-6"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span> <span class="attr">multiple</span> <span class="attr">style</span>=<span class="string">"width: 50px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vue-基本使用&quot;&gt;&lt;a href=&quot;#Vue-基本使用&quot; class=&quot;headerlink&quot; title=&quot;Vue 基本使用&quot;&gt;&lt;/a&gt;Vue 基本使用&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://chenwenkai8023ni.github.io/tags/Vue/"/>
    
  </entry>
  
</feed>
